From 3227ce9e3ea004e742f2a3390c426c9699e26a16 Mon Sep 17 00:00:00 2001
From: Fam Zheng <famz@redhat.com>
Date: Fri, 26 Jan 2018 02:07:36 +0100
Subject: [PATCH 5/8] osdep: Retry SETLK upon EINTR

RH-Author: Fam Zheng <famz@redhat.com>
Message-id: <20180126020736.24596-1-famz@redhat.com>
Patchwork-id: 78706
O-Subject: [RHV7.5 qemu-kvm-rhev PATCH] osdep: Retry SETLK upon EINTR
Bugzilla: 1529053
RH-Acked-by: Laszlo Ersek <lersek@redhat.com>
RH-Acked-by: Stefan Hajnoczi <stefanha@redhat.com>
RH-Acked-by: Kevin Wolf <kwolf@redhat.com>

We could hit lock failure if there is a signal that makes fcntl return
-1 and errno set to EINTR. In this case we should retry.

Cc: qemu-stable@nongnu.org
Signed-off-by: Fam Zheng <famz@redhat.com>
Reviewed-by: Eric Blake <eblake@redhat.com>
Signed-off-by: Kevin Wolf <kwolf@redhat.com>
(cherry picked from commit f86428a1f4f91a460ed585682af70d3e8c31dc06)
Signed-off-by: Fam Zheng <famz@redhat.com>
Signed-off-by: Miroslav Rezanina <mrezanin@redhat.com>
---
 util/osdep.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/util/osdep.c b/util/osdep.c
index 8358a44..ac7d1b2 100644
--- a/util/osdep.c
+++ b/util/osdep.c
@@ -208,7 +208,9 @@ static int qemu_lock_fcntl(int fd, int64_t start, int64_t len, int fl_type)
         .l_type   = fl_type,
     };
     qemu_probe_lock_ops();
-    ret = fcntl(fd, fcntl_op_setlk, &fl);
+    do {
+        ret = fcntl(fd, fcntl_op_setlk, &fl);
+    } while (ret == -1 && errno == EINTR);
     return ret == -1 ? -errno : 0;
 }
 
-- 
1.8.3.1

