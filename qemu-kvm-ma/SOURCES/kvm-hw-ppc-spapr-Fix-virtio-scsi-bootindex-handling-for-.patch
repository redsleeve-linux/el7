From 8a285115ee19166f22024326063d330706639914 Mon Sep 17 00:00:00 2001
From: Thomas Huth <thuth@redhat.com>
Date: Thu, 23 Nov 2017 17:50:30 +0100
Subject: [PATCH 4/7] hw/ppc/spapr: Fix virtio-scsi bootindex handling for LUNs
 >= 256

RH-Author: Thomas Huth <thuth@redhat.com>
Message-id: <1511459430-7395-2-git-send-email-thuth@redhat.com>
Patchwork-id: 77832
O-Subject: [RHEL-7.5 qemu-kvm-ma PATCH 1/1] hw/ppc/spapr: Fix virtio-scsi bootindex handling for LUNs >= 256
Bugzilla: 1515393
RH-Acked-by: Paolo Bonzini <pbonzini@redhat.com>
RH-Acked-by: Laurent Vivier <lvivier@redhat.com>
RH-Acked-by: Laszlo Ersek <lersek@redhat.com>

LUNs >= 256 have to be encoded with the so-called "flat space
addressing method" for virtio-scsi, where an additional bit has to
be set. SLOF already took care of this with the following commit:

 https://git.qemu.org/?p=SLOF.git;a=commitdiff;h=f72a37713fea47da
 (see https://bugzilla.redhat.com/show_bug.cgi?id=1431584 for details)

But QEMU does not use this encoding yet for device tree paths
that have to be handed over to SLOF to deal with the "bootindex"
property, so SLOF currently fails to boot from virtio-scsi devices
with LUNs >= 256 in the right boot order. Fix it by using the bit
to indicate the "flat space addressing method" for LUNs >= 256.

Signed-off-by: Thomas Huth <thuth@redhat.com>
Signed-off-by: David Gibson <david@gibson.dropbear.id.au>
(cherry picked from commit bac658d1a4dc9dd637b2eb5006abda137071f17f)
Signed-off-by: Miroslav Rezanina <mrezanin@redhat.com>
---
 hw/ppc/spapr.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/hw/ppc/spapr.c b/hw/ppc/spapr.c
index 96df3a7..2065f09 100644
--- a/hw/ppc/spapr.c
+++ b/hw/ppc/spapr.c
@@ -2628,6 +2628,10 @@ static char *spapr_get_fw_dev_path(FWPathProvider *p, BusState *bus,
              * swap 0100 or 10 << or 20 << ( target lun-id -- srplun )
              */
             unsigned id = 0x1000000 | (d->id << 16) | d->lun;
+            if (d->lun >= 256) {
+                /* Use the LUN "flat space addressing method" */
+                id |= 0x4000;
+            }
             return g_strdup_printf("%s@%"PRIX64, qdev_fw_name(dev),
                                    (uint64_t)id << 32);
         } else if (usb) {
-- 
1.8.3.1

