From 8308e20075adacfdf1827aaa3230e503207832bc Mon Sep 17 00:00:00 2001
From: Mark Reynolds <mreynolds@redhat.com>
Date: Mon, 2 Oct 2017 09:33:29 -0400
Subject: [PATCH] Ticket 49385 - Fix coverity warnings

Description:  This fixes coverity issues found from RHEL build of 1.3.7

https://pagure.io/389-ds-base/issue/49385

Reviewed by: lkrispenz(Thanks!)

(cherry picked from commit 805e8f4d3016eb9c7906c1416482047a234d51ba)
---
 ldap/servers/plugins/http/http_impl.c    |  1 +
 ldap/servers/plugins/replication/urp.c   | 10 ++++++----
 ldap/servers/plugins/syntaxes/string.c   |  1 +
 ldap/servers/slapd/back-ldbm/dbversion.c |  2 +-
 ldap/servers/slapd/back-ldbm/index.c     |  1 +
 ldap/servers/slapd/conntable.c           |  2 +-
 ldap/servers/slapd/modify.c              |  1 +
 ldap/servers/slapd/plugin.c              |  3 ++-
 ldap/servers/slapd/referral.c            | 18 +++++++++---------
 ldap/servers/slapd/task.c                |  8 ++++++--
 ldap/servers/snmp/main.c                 | 13 +++++++++++--
 11 files changed, 40 insertions(+), 20 deletions(-)

diff --git a/ldap/servers/plugins/http/http_impl.c b/ldap/servers/plugins/http/http_impl.c
index d8bbe38..350c839 100644
--- a/ldap/servers/plugins/http/http_impl.c
+++ b/ldap/servers/plugins/http/http_impl.c
@@ -601,6 +601,7 @@ sendPostReq(PRFileDesc *fd, const char *path, httpheader **httpheaderArray, char
     if (path) {
         path_len = strlen(path);
     } else {
+        path = "";
         path_len = 0;
     }
 
diff --git a/ldap/servers/plugins/replication/urp.c b/ldap/servers/plugins/replication/urp.c
index 3d63c64..9534c03 100644
--- a/ldap/servers/plugins/replication/urp.c
+++ b/ldap/servers/plugins/replication/urp.c
@@ -856,7 +856,7 @@ urp_post_delete_operation(Slapi_PBlock *pb)
 static int
 urp_fixup_add_cenotaph (Slapi_PBlock *pb, char *sessionid, CSN *opcsn)
 {
-    Slapi_PBlock *add_pb = slapi_pblock_new();
+    Slapi_PBlock *add_pb;
     Slapi_Entry *cenotaph = NULL;
     Slapi_Entry *pre_entry = NULL;
     int ret = 0;
@@ -886,6 +886,7 @@ urp_fixup_add_cenotaph (Slapi_PBlock *pb, char *sessionid, CSN *opcsn)
     slapi_rdn_remove_attr (rdn, SLAPI_ATTR_UNIQUEID );
     slapi_rdn_add(rdn, "cenotaphID", uniqueid);
     newdn = slapi_ch_smprintf("%s,%s", slapi_rdn_get_rdn(rdn), parentdn);
+    slapi_rdn_free(&rdn);
     slapi_ch_free_string(&parentdn);
     /* slapi_sdn_free(&pre_sdn); */
 
@@ -902,6 +903,7 @@ urp_fixup_add_cenotaph (Slapi_PBlock *pb, char *sessionid, CSN *opcsn)
 
     slapi_log_err(SLAPI_LOG_REPL, sessionid,
                    "urp_fixup_add_cenotaph - addinng cenotaph: %s \n", newdn);
+    add_pb = slapi_pblock_new();
     slapi_pblock_init(add_pb);
 
     slapi_add_entry_internal_set_pb(add_pb,
@@ -1661,8 +1663,8 @@ urp_conflict_to_glue (char *sessionid, const Slapi_Entry *entry, Slapi_DN *paren
                            "urp_conflict_to_glue failed(%d) - %s --> %s\n", op_result, basedn, newrdn);
             rc = 1;
         }
-        slapi_ch_free ( (void**)&newrdn );
     }
+    slapi_rdn_free(&parentrdn);
     return rc;
 }
 /* 
@@ -2166,11 +2168,11 @@ mod_objectclass_attr(const char *uniqueid, const Slapi_DN *entrysdn, const Slapi
 {
     Slapi_Mods smods;
     int op_result;
-    char csnstr[CSN_STRSIZE+1];
+    char csnstr[CSN_STRSIZE+1] = {0};
 
     slapi_mods_init(&smods, 3);
     slapi_mods_add(&smods, LDAP_MOD_ADD, "objectclass", strlen("ldapsubentry"),"ldapsubentry");
-    slapi_mods_add(&smods, LDAP_MOD_REPLACE, "conflictcsn", strlen(csnstr),csn_as_string(opcsn, PR_FALSE, csnstr));
+    slapi_mods_add(&smods, LDAP_MOD_REPLACE, "conflictcsn", CSN_STRSIZE, csn_as_string(opcsn, PR_FALSE, csnstr));
     op_result = urp_fixup_modify_entry(uniqueid, entrysdn, opcsn, &smods, 0);
     slapi_mods_done(&smods);
     if (op_result == LDAP_TYPE_OR_VALUE_EXISTS) {
diff --git a/ldap/servers/plugins/syntaxes/string.c b/ldap/servers/plugins/syntaxes/string.c
index f50dc13..e05ca7f 100644
--- a/ldap/servers/plugins/syntaxes/string.c
+++ b/ldap/servers/plugins/syntaxes/string.c
@@ -391,6 +391,7 @@ bailout:
     if (free_re) {
         slapi_re_free(re);
     }
+    slapi_ch_free_string(&alt);
     slapi_ch_free((void **)&tmpbuf); /* NULL is fine */
     slapi_ch_free((void **)&bigpat); /* NULL is fine */
 
diff --git a/ldap/servers/slapd/back-ldbm/dbversion.c b/ldap/servers/slapd/back-ldbm/dbversion.c
index 01f86f4..5a77abd 100644
--- a/ldap/servers/slapd/back-ldbm/dbversion.c
+++ b/ldap/servers/slapd/back-ldbm/dbversion.c
@@ -159,7 +159,7 @@ dbversion_read(struct ldbminfo *li, const char *directory, char **ldbmversion, c
         }
         (void)PR_Close(prfd);
 
-        if (*dataversion == NULL) {
+        if (dataversion == NULL || *dataversion == NULL) {
             slapi_log_err(SLAPI_LOG_DEBUG, "dbversion_read", "dataversion not present in \"%s\"\n", filename);
         }
         if (*ldbmversion == NULL) {
diff --git a/ldap/servers/slapd/back-ldbm/index.c b/ldap/servers/slapd/back-ldbm/index.c
index 798480e..58b11ed 100644
--- a/ldap/servers/slapd/back-ldbm/index.c
+++ b/ldap/servers/slapd/back-ldbm/index.c
@@ -1063,6 +1063,7 @@ index_read_ext_allids(
             /* The database might not exist. We have to assume it means empty set */
             slapi_log_err(SLAPI_LOG_TRACE, "index_read_ext_allids", "Failed to access idl index for %s\n", basetype);
             slapi_log_err(SLAPI_LOG_TRACE, "index_read_ext_allids", "Assuming %s has no index values\n", basetype);
+            idl_free(&idl);
             idl = idl_alloc(0);
             break;
         } else {
diff --git a/ldap/servers/slapd/conntable.c b/ldap/servers/slapd/conntable.c
index c04ca0f..7c57b47 100644
--- a/ldap/servers/slapd/conntable.c
+++ b/ldap/servers/slapd/conntable.c
@@ -347,7 +347,7 @@ connection_table_as_entry(Connection_Table *ct, Slapi_Entry *e)
 
         PR_EnterMonitor(ct->c[i].c_mutex);
         if (ct->c[i].c_sd != SLAPD_INVALID_SOCKET) {
-            char buf2[20];
+            char buf2[SLAPI_TIMESTAMP_BUFSIZE+1];
             size_t lendn = ct->c[i].c_dn ? strlen(ct->c[i].c_dn) : 6; /* "NULLDN" */
             size_t lenip = ct->c[i].c_ipaddr ? strlen(ct->c[i].c_ipaddr) : 0;
             size_t lenconn = 1;
diff --git a/ldap/servers/slapd/modify.c b/ldap/servers/slapd/modify.c
index 4b5a676..6309975 100644
--- a/ldap/servers/slapd/modify.c
+++ b/ldap/servers/slapd/modify.c
@@ -923,6 +923,7 @@ op_shared_modify(Slapi_PBlock *pb, int pw_change, char *old_pw)
             if (pw_encodevals_ext(pb, sdn, va)) {
                 slapi_log_err(SLAPI_LOG_CRIT, "op_shared_modify", "Unable to hash userPassword attribute for %s.\n", slapi_entry_get_dn_const(e));
                 send_ldap_result(pb, LDAP_UNWILLING_TO_PERFORM, NULL, "Unable to store attribute \"userPassword\" correctly\n", 0, NULL);
+                valuearray_free(&va);
                 goto free_and_return;
             }
 
diff --git a/ldap/servers/slapd/plugin.c b/ldap/servers/slapd/plugin.c
index f47ff9b..e02133a 100644
--- a/ldap/servers/slapd/plugin.c
+++ b/ldap/servers/slapd/plugin.c
@@ -4242,7 +4242,7 @@ bail:
 int
 slapi_set_plugin_default_config(const char *type, Slapi_Value *value)
 {
-    Slapi_PBlock *pb = slapi_pblock_new();
+    Slapi_PBlock *pb;
     Slapi_Entry **entries = NULL;
     int rc = LDAP_SUCCESS;
     char **search_attrs = NULL; /* used by search */
@@ -4251,6 +4251,7 @@ slapi_set_plugin_default_config(const char *type, Slapi_Value *value)
         return rc;
     }
 
+    pb = slapi_pblock_new();
     charray_add(&search_attrs, slapi_ch_strdup(type));
 
     /* cn=plugin default config,cn=config */
diff --git a/ldap/servers/slapd/referral.c b/ldap/servers/slapd/referral.c
index c5d9ffc..5935820 100644
--- a/ldap/servers/slapd/referral.c
+++ b/ldap/servers/slapd/referral.c
@@ -153,7 +153,7 @@ referrals_free(void)
 struct berval **
 ref_adjust(Slapi_PBlock *pb, struct berval **urls, const Slapi_DN *refsdn, int is_reference)
 {
-    int i, len, scope;
+    int i, len, scope = 0;
     Slapi_DN *sdn = NULL;
     char *p, *opdn_norm;
     struct berval **urlscopy;
@@ -195,9 +195,9 @@ ref_adjust(Slapi_PBlock *pb, struct berval **urls, const Slapi_DN *refsdn, int i
 
     for (i = 0; urls[i] != NULL; ++i) {
         /*
-     * duplicate the URL, stripping off the label if there is one and
-     * leaving extra room for "??base" in case we need to append that.
-     */
+         * duplicate the URL, stripping off the label if there is one and
+         * leaving extra room for "??base" in case we need to append that.
+         */
         urlscopy[i] = (struct berval *)slapi_ch_malloc(
             sizeof(struct berval));
         if ((p = strchr(urls[i]->bv_val, ' ')) == NULL) {
@@ -210,16 +210,16 @@ ref_adjust(Slapi_PBlock *pb, struct berval **urls, const Slapi_DN *refsdn, int i
         urlscopy[i]->bv_val[len] = '\0';
 
         /*
-     * adjust the baseDN as needed and set the length
-     */
+         * adjust the baseDN as needed and set the length
+         */
         adjust_referral_basedn(&urlscopy[i]->bv_val, refsdn,
                                opdn_norm, is_reference);
         urlscopy[i]->bv_len = strlen(urlscopy[i]->bv_val);
 
         /*
-     * if we are dealing with a continuation reference that resulted
-     * from a one-level search, add a scope of base to the URL.
-     */
+         * if we are dealing with a continuation reference that resulted
+         * from a one-level search, add a scope of base to the URL.
+         */
         if (is_reference && operation_get_type(op) == SLAPI_OPERATION_SEARCH &&
             scope == LDAP_SCOPE_ONELEVEL) {
             strcat(urlscopy[i]->bv_val, "??base");
diff --git a/ldap/servers/slapd/task.c b/ldap/servers/slapd/task.c
index f3d02d9..53a0af5 100644
--- a/ldap/servers/slapd/task.c
+++ b/ldap/servers/slapd/task.c
@@ -278,6 +278,10 @@ slapi_task_log_notice(Slapi_Task *task, char *format, ...)
     char buffer[LOG_BUFFER];
     size_t len;
 
+    if (task == NULL) {
+        return;
+    }
+
     va_start(ap, format);
     PR_vsnprintf(buffer, LOG_BUFFER, format, ap);
     va_end(ap);
@@ -1089,11 +1093,11 @@ task_export_thread(void *arg)
     slapi_pblock_get(pb, SLAPI_BACKEND_TASK, &task);
 
     g_incr_active_threadcnt();
-    for (count = 0, inp = instance_names; *inp; inp++, count++)
+    for (count = 0, inp = instance_names; inp && *inp; inp++, count++)
         ;
     slapi_task_begin(task, count);
 
-    for (inp = instance_names; *inp; inp++) {
+    for (inp = instance_names; inp && *inp; inp++) {
         int release_me = 0;
         /* lookup the backend */
         be = slapi_be_select_by_instance_name((const char *)*inp);
diff --git a/ldap/servers/snmp/main.c b/ldap/servers/snmp/main.c
index 8477831..5bd318d 100644
--- a/ldap/servers/snmp/main.c
+++ b/ldap/servers/snmp/main.c
@@ -21,6 +21,7 @@
 #include "ldap.h"
 #include "ldif.h"
 #include <ctype.h>
+#include <errno.h>
 
 static char *agentx_master = NULL;
 static char *agent_logdir = NULL;
@@ -54,9 +55,17 @@ main(int argc, char *argv[])
     {
         char *s = getenv("DEBUG_SLEEP");
         if ((s != NULL) && isdigit(*s)) {
-            int secs = atoi(s);
+            char *endp = NULL;
+            long secs;
+            errno = 0;
+
             printf("%s pid is %d\n", argv[0], getpid());
-            sleep(secs);
+            secs = strtol(s, &endp, 10);
+            if (*endp != '\0' || errno == ERANGE) {
+                sleep(10);
+            } else {
+                sleep(secs);
+            }
         }
     }
 
-- 
2.9.5

