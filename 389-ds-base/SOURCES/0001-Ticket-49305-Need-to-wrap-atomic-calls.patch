From 76e8c99e00f776fdab6cf834923d19f911f06fb9 Mon Sep 17 00:00:00 2001
From: Mark Reynolds <mreynolds@redhat.com>
Date: Thu, 28 Sep 2017 10:38:20 -0400
Subject: [PATCH] Ticket 49305 - Need to wrap atomic calls

Bug Description:  Some RHEL 7.5 platforms (ppc 32bit) still do not support
                  all the gcc built-in atomics.  This breaks the downstream
                  builds.

Fix Description:  Use wrapper functions for the atomic's using #define's
                  to detect if builtin atomics are supported, otherwise
                  use the generic nspr atomic functions.

https://pagure.io/389-ds-base/issue/49305

Reviewed by: tbordaz, lkrispen, and wibrown(Thanks!!!)

(cherry picked from commit 93a29584ddae52497b898b451c2c810244627acb)
---
 ldap/servers/slapd/attrsyntax.c        |   8 +-
 ldap/servers/slapd/back-ldbm/dblayer.c |   8 +-
 ldap/servers/slapd/entry.c             |   8 +-
 ldap/servers/slapd/libglobs.c          | 154 ++++++++++++++++-----------------
 ldap/servers/slapd/log.c               |   9 +-
 ldap/servers/slapd/mapping_tree.c      |  28 +++---
 ldap/servers/slapd/object.c            |   7 +-
 ldap/servers/slapd/psearch.c           |   7 +-
 ldap/servers/slapd/slapi-plugin.h      |  65 ++++++++++----
 ldap/servers/slapd/slapi_counter.c     | 113 +++++++++++++-----------
 10 files changed, 223 insertions(+), 184 deletions(-)

diff --git a/ldap/servers/slapd/attrsyntax.c b/ldap/servers/slapd/attrsyntax.c
index a0a60c4..1a9efef 100644
--- a/ldap/servers/slapd/attrsyntax.c
+++ b/ldap/servers/slapd/attrsyntax.c
@@ -274,7 +274,7 @@ attr_syntax_get_by_oid_locking_optional(const char *oid, PRBool use_lock, PRUint
         }
         asi = (struct asyntaxinfo *)PL_HashTableLookup_const(ht, oid);
         if (asi) {
-            slapi_atomic_incr(&(asi->asi_refcnt), __ATOMIC_RELEASE, ATOMIC_LONG);
+            slapi_atomic_incr_64(&(asi->asi_refcnt), __ATOMIC_RELEASE);
         }
         if (use_lock) {
             AS_UNLOCK_READ(oid2asi_lock);
@@ -371,7 +371,7 @@ attr_syntax_get_by_name_locking_optional(const char *name, PRBool use_lock, PRUi
         }
         asi = (struct asyntaxinfo *)PL_HashTableLookup_const(ht, name);
         if (NULL != asi) {
-            slapi_atomic_incr(&(asi->asi_refcnt), __ATOMIC_RELEASE, ATOMIC_LONG);
+            slapi_atomic_incr_64(&(asi->asi_refcnt), __ATOMIC_RELEASE);
         }
         if (use_lock) {
             AS_UNLOCK_READ(name2asi_lock);
@@ -406,7 +406,7 @@ attr_syntax_return_locking_optional(struct asyntaxinfo *asi, PRBool use_lock)
     }
     if (NULL != asi) {
         PRBool delete_it = PR_FALSE;
-        if (0 == slapi_atomic_decr(&(asi->asi_refcnt), __ATOMIC_ACQ_REL, ATOMIC_LONG)) {
+        if (0 == slapi_atomic_decr_64(&(asi->asi_refcnt), __ATOMIC_ACQ_REL)) {
             delete_it = asi->asi_marked_for_delete;
         }
 
@@ -540,7 +540,7 @@ attr_syntax_delete_no_lock(struct asyntaxinfo *asi,
                 PL_HashTableRemove(ht, asi->asi_aliases[i]);
             }
         }
-        if (slapi_atomic_load(&(asi->asi_refcnt), __ATOMIC_ACQUIRE, ATOMIC_LONG) > 0) {
+        if (slapi_atomic_load_64(&(asi->asi_refcnt), __ATOMIC_ACQUIRE) > 0) {
             asi->asi_marked_for_delete = PR_TRUE;
         } else {
             /* This is ok, but the correct thing is to call delete first,
diff --git a/ldap/servers/slapd/back-ldbm/dblayer.c b/ldap/servers/slapd/back-ldbm/dblayer.c
index c4c4959..9e557a2 100644
--- a/ldap/servers/slapd/back-ldbm/dblayer.c
+++ b/ldap/servers/slapd/back-ldbm/dblayer.c
@@ -2880,7 +2880,7 @@ dblayer_get_index_file(backend *be, struct attrinfo *a, DB **ppDB, int open_flag
     /* it's like a semaphore -- when count > 0, any file handle that's in
      * the attrinfo will remain valid from here on.
      */
-    slapi_atomic_incr(&(a->ai_dblayer_count), __ATOMIC_RELEASE, ATOMIC_LONG);
+    slapi_atomic_incr_64(&(a->ai_dblayer_count), __ATOMIC_RELEASE);
 
     if (a->ai_dblayer && ((dblayer_handle *)(a->ai_dblayer))->dblayer_dbp) {
         /* This means that the pointer is valid, so we should return it. */
@@ -2938,7 +2938,7 @@ dblayer_get_index_file(backend *be, struct attrinfo *a, DB **ppDB, int open_flag
         /* some sort of error -- we didn't open a handle at all.
          * decrement the refcount back to where it was.
          */
-        slapi_atomic_decr(&(a->ai_dblayer_count), __ATOMIC_RELEASE, ATOMIC_LONG);
+        slapi_atomic_decr_64(&(a->ai_dblayer_count), __ATOMIC_RELEASE);
     }
 
     return return_value;
@@ -2950,7 +2950,7 @@ dblayer_get_index_file(backend *be, struct attrinfo *a, DB **ppDB, int open_flag
 int
 dblayer_release_index_file(backend *be __attribute__((unused)), struct attrinfo *a, DB *pDB __attribute__((unused)))
 {
-    slapi_atomic_decr(&(a->ai_dblayer_count), __ATOMIC_RELEASE, ATOMIC_LONG);
+    slapi_atomic_decr_64(&(a->ai_dblayer_count), __ATOMIC_RELEASE);
     return 0;
 }
 
@@ -3057,7 +3057,7 @@ dblayer_erase_index_file_ex(backend *be, struct attrinfo *a, PRBool use_lock, in
 
             dblayer_release_index_file(be, a, db);
 
-            while (slapi_atomic_load(&(a->ai_dblayer_count), __ATOMIC_ACQUIRE, ATOMIC_LONG) > 0) {
+            while (slapi_atomic_load_64(&(a->ai_dblayer_count), __ATOMIC_ACQUIRE) > 0) {
                 /* someone is using this index file */
                 /* ASSUMPTION: you have already set the INDEX_OFFLINE flag, because
                  * you intend to mess with this index.  therefore no new requests
diff --git a/ldap/servers/slapd/entry.c b/ldap/servers/slapd/entry.c
index 289a149..fbbc8fa 100644
--- a/ldap/servers/slapd/entry.c
+++ b/ldap/servers/slapd/entry.c
@@ -2249,14 +2249,14 @@ static int32_t g_virtual_watermark = 0; /* good enough to init */
 int
 slapi_entry_vattrcache_watermark_isvalid(const Slapi_Entry *e)
 {
-    return e->e_virtual_watermark == slapi_atomic_load(&g_virtual_watermark, __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return e->e_virtual_watermark == slapi_atomic_load_32(&g_virtual_watermark, __ATOMIC_ACQUIRE);
 
 }
 
 void
 slapi_entry_vattrcache_watermark_set(Slapi_Entry *e)
 {
-    e->e_virtual_watermark = slapi_atomic_load(&g_virtual_watermark, __ATOMIC_ACQUIRE, ATOMIC_INT);
+    e->e_virtual_watermark = slapi_atomic_load_32(&g_virtual_watermark, __ATOMIC_ACQUIRE);
 }
 
 void
@@ -2269,8 +2269,8 @@ void
 slapi_entrycache_vattrcache_watermark_invalidate()
 {
     /* Make sure the value is never 0 */
-    if (slapi_atomic_incr(&g_virtual_watermark, __ATOMIC_RELEASE, ATOMIC_INT) == 0) {
-        slapi_atomic_incr(&g_virtual_watermark, __ATOMIC_RELEASE, ATOMIC_INT);
+    if (slapi_atomic_incr_32(&g_virtual_watermark, __ATOMIC_RELEASE) == 0) {
+        slapi_atomic_incr_32(&g_virtual_watermark, __ATOMIC_RELEASE);
     }
 }
 
diff --git a/ldap/servers/slapd/libglobs.c b/ldap/servers/slapd/libglobs.c
index 4c54cf7..1ba3000 100644
--- a/ldap/servers/slapd/libglobs.c
+++ b/ldap/servers/slapd/libglobs.c
@@ -1335,19 +1335,19 @@ static uint64_t active_threads = 0;
 void
 g_incr_active_threadcnt(void)
 {
-    slapi_atomic_incr(&active_threads, __ATOMIC_RELEASE, ATOMIC_LONG);
+    slapi_atomic_incr_64(&active_threads, __ATOMIC_RELEASE);
 }
 
 void
 g_decr_active_threadcnt(void)
 {
-    slapi_atomic_decr(&active_threads, __ATOMIC_RELEASE, ATOMIC_LONG);
+    slapi_atomic_decr_64(&active_threads, __ATOMIC_RELEASE);
 }
 
 uint64_t
 g_get_active_threadcnt(void)
 {
-    return slapi_atomic_load(&active_threads, __ATOMIC_RELEASE, ATOMIC_LONG);
+    return slapi_atomic_load_64(&active_threads, __ATOMIC_RELEASE);
 }
 
 /*
@@ -1936,7 +1936,7 @@ config_set_ndn_cache_max_size(const char *attrname, char *value, char *errorbuf,
         size = NDN_DEFAULT_SIZE;
     }
     if (apply) {
-        slapi_atomic_store(&(slapdFrontendConfig->ndn_cache_max_size), &size, __ATOMIC_RELEASE, ATOMIC_LONG);
+        slapi_atomic_store_64(&(slapdFrontendConfig->ndn_cache_max_size), size, __ATOMIC_RELEASE);
     }
 
     return retVal;
@@ -3476,7 +3476,7 @@ int32_t
 config_get_dynamic_plugins(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->dynamic_plugins), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->dynamic_plugins), __ATOMIC_ACQUIRE);
 
 }
 
@@ -3499,7 +3499,7 @@ int32_t
 config_get_cn_uses_dn_syntax_in_dns()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->cn_uses_dn_syntax_in_dns), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->cn_uses_dn_syntax_in_dns), __ATOMIC_ACQUIRE);
 }
 
 int32_t
@@ -3544,7 +3544,7 @@ config_set_onoff(const char *attrname, char *value, int32_t *configvalue, char *
         newval = LDAP_OFF;
     }
 
-    slapi_atomic_store(configvalue, &newval, __ATOMIC_RELEASE, ATOMIC_INT);
+    slapi_atomic_store_32(configvalue, newval, __ATOMIC_RELEASE);
 
     return retVal;
 }
@@ -3916,7 +3916,7 @@ config_set_threadnumber(const char *attrname, char *value, char *errorbuf, int a
         retVal = LDAP_OPERATIONS_ERROR;
     }
     if (apply) {
-        slapi_atomic_store(&(slapdFrontendConfig->threadnumber), &threadnum, __ATOMIC_RELAXED, ATOMIC_INT);
+        slapi_atomic_store_32(&(slapdFrontendConfig->threadnumber), threadnum, __ATOMIC_RELAXED);
     }
     return retVal;
 }
@@ -3925,7 +3925,7 @@ int
 config_set_maxthreadsperconn(const char *attrname, char *value, char *errorbuf, int apply)
 {
     int retVal = LDAP_SUCCESS;
-    long maxthreadnum = 0;
+    int32_t maxthreadnum = 0;
     char *endp = NULL;
 
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
@@ -3935,7 +3935,7 @@ config_set_maxthreadsperconn(const char *attrname, char *value, char *errorbuf,
     }
 
     errno = 0;
-    maxthreadnum = strtol(value, &endp, 10);
+    maxthreadnum = (int32_t)strtol(value, &endp, 10);
 
     if (*endp != '\0' || errno == ERANGE || maxthreadnum < 1 || maxthreadnum > 65535) {
         slapi_create_errormsg(errorbuf, SLAPI_DSE_RETURNTEXT_SIZE,
@@ -3945,7 +3945,7 @@ config_set_maxthreadsperconn(const char *attrname, char *value, char *errorbuf,
     }
 
     if (apply) {
-        slapi_atomic_store(&(slapdFrontendConfig->maxthreadsperconn), &maxthreadnum, __ATOMIC_RELEASE, ATOMIC_INT);
+        slapi_atomic_store_32(&(slapdFrontendConfig->maxthreadsperconn), maxthreadnum, __ATOMIC_RELEASE);
     }
     return retVal;
 }
@@ -4083,7 +4083,7 @@ int
 config_set_ioblocktimeout(const char *attrname, char *value, char *errorbuf, int apply)
 {
     int retVal = LDAP_SUCCESS;
-    long nValue = 0;
+    int32_t nValue = 0;
     char *endp = NULL;
 
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
@@ -4093,7 +4093,7 @@ config_set_ioblocktimeout(const char *attrname, char *value, char *errorbuf, int
     }
 
     errno = 0;
-    nValue = strtol(value, &endp, 10);
+    nValue = (int32_t)strtol(value, &endp, 10);
 
     if (*endp != '\0' || errno == ERANGE || nValue < 0) {
         slapi_create_errormsg(errorbuf, SLAPI_DSE_RETURNTEXT_SIZE, "%s: invalid value \"%s\", I/O block timeout must range from 0 to %lld",
@@ -4103,7 +4103,7 @@ config_set_ioblocktimeout(const char *attrname, char *value, char *errorbuf, int
     }
 
     if (apply) {
-        slapi_atomic_store(&(slapdFrontendConfig->ioblocktimeout), &nValue, __ATOMIC_RELEASE, ATOMIC_INT);
+        slapi_atomic_store_32(&(slapdFrontendConfig->ioblocktimeout), nValue, __ATOMIC_RELEASE);
     }
     return retVal;
 }
@@ -4607,7 +4607,7 @@ int32_t
 config_get_sasl_mapping_fallback()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->sasl_mapping_fallback), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->sasl_mapping_fallback), __ATOMIC_ACQUIRE);
 
 }
 
@@ -4615,14 +4615,14 @@ int32_t
 config_get_disk_monitoring()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->disk_monitoring), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->disk_monitoring), __ATOMIC_ACQUIRE);
 }
 
 int32_t
 config_get_disk_logging_critical()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->disk_logging_critical), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->disk_logging_critical), __ATOMIC_ACQUIRE);
 }
 
 int
@@ -4669,14 +4669,14 @@ int32_t
 config_get_ldapi_switch()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->ldapi_switch), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->ldapi_switch), __ATOMIC_ACQUIRE);
 }
 
 int32_t
 config_get_ldapi_bind_switch()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->ldapi_bind_switch), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->ldapi_bind_switch), __ATOMIC_ACQUIRE);
 }
 
 char *
@@ -4695,7 +4695,7 @@ int
 config_get_ldapi_map_entries()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->ldapi_map_entries), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->ldapi_map_entries), __ATOMIC_ACQUIRE);
 }
 
 char *
@@ -4765,7 +4765,7 @@ int32_t
 config_get_slapi_counters()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->slapi_counters), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->slapi_counters), __ATOMIC_ACQUIRE);
 
 }
 
@@ -4948,7 +4948,7 @@ int32_t
 config_get_pw_change(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->pw_policy.pw_change), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->pw_policy.pw_change), __ATOMIC_ACQUIRE);
 }
 
 
@@ -4956,7 +4956,7 @@ int32_t
 config_get_pw_history(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->pw_policy.pw_history), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->pw_policy.pw_history), __ATOMIC_ACQUIRE);
 }
 
 
@@ -4964,21 +4964,21 @@ int32_t
 config_get_pw_must_change(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->pw_policy.pw_must_change), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->pw_policy.pw_must_change), __ATOMIC_ACQUIRE);
 }
 
 int32_t
 config_get_allow_hashed_pw(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->allow_hashed_pw), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->allow_hashed_pw), __ATOMIC_ACQUIRE);
 }
 
 int32_t
 config_get_pw_syntax(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->pw_policy.pw_syntax), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->pw_policy.pw_syntax), __ATOMIC_ACQUIRE);
 }
 
 
@@ -5167,21 +5167,21 @@ int32_t
 config_get_pw_is_global_policy(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->pw_is_global_policy), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->pw_is_global_policy), __ATOMIC_ACQUIRE);
 }
 
 int32_t
 config_get_pw_is_legacy_policy(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->pw_policy.pw_is_legacy), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->pw_policy.pw_is_legacy), __ATOMIC_ACQUIRE);
 }
 
 int32_t
 config_get_pw_exp(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->pw_policy.pw_exp), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->pw_policy.pw_exp), __ATOMIC_ACQUIRE);
 }
 
 
@@ -5189,14 +5189,14 @@ int32_t
 config_get_pw_unlock(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->pw_policy.pw_unlock), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->pw_policy.pw_unlock), __ATOMIC_ACQUIRE);
 }
 
 int32_t
 config_get_pw_lockout()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->pw_policy.pw_lockout), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->pw_policy.pw_lockout), __ATOMIC_ACQUIRE);
 }
 
 int
@@ -5216,112 +5216,112 @@ int32_t
 config_get_lastmod()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->lastmod), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->lastmod), __ATOMIC_ACQUIRE);
 }
 
 int32_t
 config_get_enquote_sup_oc()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->enquote_sup_oc), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->enquote_sup_oc), __ATOMIC_ACQUIRE);
 }
 
 int32_t
 config_get_nagle(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->nagle), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->nagle), __ATOMIC_ACQUIRE);
 }
 
 int32_t
 config_get_accesscontrol(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->accesscontrol), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->accesscontrol), __ATOMIC_ACQUIRE);
 }
 
 int32_t
 config_get_return_exact_case(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->return_exact_case), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->return_exact_case), __ATOMIC_ACQUIRE);
 }
 
 int32_t
 config_get_result_tweak(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->result_tweak), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->result_tweak), __ATOMIC_ACQUIRE);
 }
 
 int32_t
 config_get_moddn_aci(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->moddn_aci), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->moddn_aci), __ATOMIC_ACQUIRE);
 }
 
 int32_t
 config_get_security(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->security), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->security), __ATOMIC_ACQUIRE);
 }
 
 int32_t
 slapi_config_get_readonly(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->readonly), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->readonly), __ATOMIC_ACQUIRE);
 }
 
 int32_t
 config_get_schemacheck(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->schemacheck), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->schemacheck), __ATOMIC_ACQUIRE);
 }
 
 int32_t
 config_get_schemamod(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->schemamod), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->schemamod), __ATOMIC_ACQUIRE);
 }
 
 int32_t
 config_get_syntaxcheck(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->syntaxcheck), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->syntaxcheck), __ATOMIC_ACQUIRE);
 }
 
 int32_t
 config_get_syntaxlogging(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->syntaxlogging), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->syntaxlogging), __ATOMIC_ACQUIRE);
 }
 
 int32_t
 config_get_dn_validate_strict(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->dn_validate_strict), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->dn_validate_strict), __ATOMIC_ACQUIRE);
 }
 
 int32_t
 config_get_ds4_compatible_schema(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->ds4_compatible_schema), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->ds4_compatible_schema), __ATOMIC_ACQUIRE);
 }
 
 int32_t
 config_get_schema_ignore_trailing_spaces(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->schema_ignore_trailing_spaces), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->schema_ignore_trailing_spaces), __ATOMIC_ACQUIRE);
 }
 
 char *
@@ -5405,7 +5405,7 @@ config_get_threadnumber(void)
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
     int32_t retVal;
 
-    retVal = slapi_atomic_load(&(slapdFrontendConfig->threadnumber), __ATOMIC_RELAXED, ATOMIC_INT);
+    retVal = slapi_atomic_load_32(&(slapdFrontendConfig->threadnumber), __ATOMIC_RELAXED);
 
     if (retVal <= 0) {
         retVal = util_get_hardware_threads();
@@ -5423,7 +5423,7 @@ int32_t
 config_get_maxthreadsperconn()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->maxthreadsperconn), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->maxthreadsperconn), __ATOMIC_ACQUIRE);
 }
 
 int
@@ -5455,7 +5455,7 @@ int32_t
 config_get_ioblocktimeout()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->ioblocktimeout), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->ioblocktimeout), __ATOMIC_ACQUIRE);
 }
 
 int
@@ -5772,21 +5772,21 @@ int32_t
 config_get_unauth_binds_switch(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->allow_unauth_binds), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->allow_unauth_binds), __ATOMIC_ACQUIRE);
 }
 
 int32_t
 config_get_require_secure_binds(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->require_secure_binds), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->require_secure_binds), __ATOMIC_ACQUIRE);
 }
 
 int32_t
 config_get_anon_access_switch(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->allow_anon_access), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->allow_anon_access), __ATOMIC_ACQUIRE);
 }
 
 int
@@ -6028,7 +6028,7 @@ int32_t
 config_get_minssf_exclude_rootdse()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->minssf_exclude_rootdse), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->minssf_exclude_rootdse), __ATOMIC_ACQUIRE);
 
 }
 
@@ -6057,7 +6057,7 @@ config_set_max_filter_nest_level(const char *attrname, char *value, char *errorb
         return retVal;
     }
 
-    slapi_atomic_store(&(slapdFrontendConfig->max_filter_nest_level), &level, __ATOMIC_RELEASE, ATOMIC_INT);
+    slapi_atomic_store_32(&(slapdFrontendConfig->max_filter_nest_level), level, __ATOMIC_RELEASE);
     return retVal;
 }
 
@@ -6065,28 +6065,28 @@ int32_t
 config_get_max_filter_nest_level()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->max_filter_nest_level), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->max_filter_nest_level), __ATOMIC_ACQUIRE);
 }
 
 uint64_t
 config_get_ndn_cache_size()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->ndn_cache_max_size), __ATOMIC_ACQUIRE, ATOMIC_LONG);
+    return slapi_atomic_load_64(&(slapdFrontendConfig->ndn_cache_max_size), __ATOMIC_ACQUIRE);
 }
 
 int32_t
 config_get_ndn_cache_enabled()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->ndn_cache_enabled), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->ndn_cache_enabled), __ATOMIC_ACQUIRE);
 }
 
 int32_t
 config_get_return_orig_type_switch()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->return_orig_type), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->return_orig_type), __ATOMIC_ACQUIRE);
 }
 
 char *
@@ -6788,7 +6788,7 @@ int32_t
 config_get_force_sasl_external(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->force_sasl_external), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->force_sasl_external), __ATOMIC_ACQUIRE);
 }
 
 int32_t
@@ -6810,7 +6810,7 @@ int32_t
 config_get_entryusn_global(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->entryusn_global), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->entryusn_global), __ATOMIC_ACQUIRE);
 }
 
 int32_t
@@ -7048,21 +7048,21 @@ int32_t
 config_get_enable_turbo_mode(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->enable_turbo_mode), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->enable_turbo_mode), __ATOMIC_ACQUIRE);
 }
 
 int32_t
 config_get_connection_nocanon(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->connection_nocanon), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->connection_nocanon), __ATOMIC_ACQUIRE);
 }
 
 int32_t
 config_get_plugin_logging(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->plugin_logging), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->plugin_logging), __ATOMIC_ACQUIRE);
 }
 
 int32_t
@@ -7075,21 +7075,21 @@ int32_t
 config_get_unhashed_pw_switch()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->unhashed_pw_switch), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->unhashed_pw_switch), __ATOMIC_ACQUIRE);
 }
 
 int32_t
 config_get_ignore_time_skew(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->ignore_time_skew), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->ignore_time_skew), __ATOMIC_ACQUIRE);
 }
 
 int32_t
 config_get_global_backend_lock()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return slapi_atomic_load(&(slapdFrontendConfig->global_backend_lock), __ATOMIC_ACQUIRE, ATOMIC_INT);
+    return slapi_atomic_load_32(&(slapdFrontendConfig->global_backend_lock), __ATOMIC_ACQUIRE);
 }
 
 int32_t
@@ -7185,7 +7185,7 @@ config_set_connection_buffer(const char *attrname, char *value, char *errorbuf,
     }
 
     val = atoi(value);
-    slapi_atomic_store(&(slapdFrontendConfig->connection_buffer), &val, __ATOMIC_RELEASE, ATOMIC_INT);
+    slapi_atomic_store_32(&(slapdFrontendConfig->connection_buffer), val, __ATOMIC_RELEASE);
 
     return retVal;
 }
@@ -7209,7 +7209,7 @@ config_set_listen_backlog_size(const char *attrname, char *value, char *errorbuf
     }
 
     if (apply) {
-        slapi_atomic_store(&(slapdFrontendConfig->listen_backlog_size), &size, __ATOMIC_RELEASE, ATOMIC_INT);
+        slapi_atomic_store_32(&(slapdFrontendConfig->listen_backlog_size), size, __ATOMIC_RELEASE);
     }
     return LDAP_SUCCESS;
 }
@@ -7622,7 +7622,7 @@ config_set_accesslog_enabled(int value)
     char errorbuf[SLAPI_DSE_RETURNTEXT_SIZE];
     errorbuf[0] = '\0';
 
-    slapi_atomic_store(&(slapdFrontendConfig->accesslog_logging_enabled), &value, __ATOMIC_RELEASE, ATOMIC_INT);
+    slapi_atomic_store_32(&(slapdFrontendConfig->accesslog_logging_enabled), value, __ATOMIC_RELEASE);
     if (value) {
         log_set_logging(CONFIG_ACCESSLOG_LOGGING_ENABLED_ATTRIBUTE, "on", SLAPD_ACCESS_LOG, errorbuf, CONFIG_APPLY);
     } else {
@@ -7640,7 +7640,7 @@ config_set_auditlog_enabled(int value)
     char errorbuf[SLAPI_DSE_RETURNTEXT_SIZE];
     errorbuf[0] = '\0';
 
-    slapi_atomic_store(&(slapdFrontendConfig->auditlog_logging_enabled), &value, __ATOMIC_RELEASE, ATOMIC_INT);
+    slapi_atomic_store_32(&(slapdFrontendConfig->auditlog_logging_enabled), value, __ATOMIC_RELEASE);
     if (value) {
         log_set_logging(CONFIG_AUDITLOG_LOGGING_ENABLED_ATTRIBUTE, "on", SLAPD_AUDIT_LOG, errorbuf, CONFIG_APPLY);
     } else {
@@ -7658,7 +7658,7 @@ config_set_auditfaillog_enabled(int value)
     char errorbuf[SLAPI_DSE_RETURNTEXT_SIZE];
     errorbuf[0] = '\0';
 
-    slapi_atomic_store(&(slapdFrontendConfig->auditfaillog_logging_enabled), &value, __ATOMIC_RELEASE, ATOMIC_INT);
+    slapi_atomic_store_32(&(slapdFrontendConfig->auditfaillog_logging_enabled), value, __ATOMIC_RELEASE);
     if (value) {
         log_set_logging(CONFIG_AUDITFAILLOG_LOGGING_ENABLED_ATTRIBUTE, "on", SLAPD_AUDITFAIL_LOG, errorbuf, CONFIG_APPLY);
     } else {
@@ -7736,7 +7736,7 @@ config_set_malloc_mxfast(const char *attrname, char *value, char *errorbuf, int
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
     int max = 80 * (sizeof(size_t) / 4);
-    int mxfast;
+    int32_t mxfast;
     char *endp = NULL;
 
     if (config_value_is_null(attrname, value, errorbuf, 0)) {
@@ -7749,7 +7749,7 @@ config_set_malloc_mxfast(const char *attrname, char *value, char *errorbuf, int
                               value, CONFIG_MALLOC_MXFAST, max);
         return LDAP_OPERATIONS_ERROR;
     }
-    slapi_atomic_store(&(slapdFrontendConfig->malloc_mxfast), &mxfast, __ATOMIC_RELEASE, ATOMIC_INT);
+    slapi_atomic_store_32(&(slapdFrontendConfig->malloc_mxfast), mxfast, __ATOMIC_RELEASE);
 
     if ((mxfast >= 0) && (mxfast <= max)) {
         mallopt(M_MXFAST, mxfast);
@@ -7775,7 +7775,7 @@ int
 config_set_malloc_trim_threshold(const char *attrname, char *value, char *errorbuf, int apply __attribute__((unused)))
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    int trim_threshold;
+    int32_t trim_threshold;
     char *endp = NULL;
 
     if (config_value_is_null(attrname, value, errorbuf, 0)) {
@@ -7789,7 +7789,7 @@ config_set_malloc_trim_threshold(const char *attrname, char *value, char *errorb
         return LDAP_OPERATIONS_ERROR;
     }
 
-    slapi_atomic_store(&(slapdFrontendConfig->malloc_trim_threshold), &trim_threshold, __ATOMIC_RELEASE, ATOMIC_INT);
+    slapi_atomic_store_32(&(slapdFrontendConfig->malloc_trim_threshold), trim_threshold, __ATOMIC_RELEASE);
 
     if (trim_threshold >= -1) {
         mallopt(M_TRIM_THRESHOLD, trim_threshold);
@@ -7836,7 +7836,7 @@ config_set_malloc_mmap_threshold(const char *attrname, char *value, char *errorb
         return LDAP_OPERATIONS_ERROR;
     }
 
-    slapi_atomic_store(&(slapdFrontendConfig->malloc_mmap_threshold), &mmap_threshold, __ATOMIC_RELEASE, ATOMIC_INT);
+    slapi_atomic_store_32(&(slapdFrontendConfig->malloc_mmap_threshold), mmap_threshold, __ATOMIC_RELEASE);
 
     if ((mmap_threshold >= 0) && (mmap_threshold <= max)) {
         mallopt(M_MMAP_THRESHOLD, mmap_threshold);
diff --git a/ldap/servers/slapd/log.c b/ldap/servers/slapd/log.c
index 4d44c87..e16d89c 100644
--- a/ldap/servers/slapd/log.c
+++ b/ldap/servers/slapd/log.c
@@ -4942,13 +4942,12 @@ static LogBufferInfo *
 log_create_buffer(size_t sz)
 {
     LogBufferInfo *lbi;
-    uint64_t init_val = 0;
 
     lbi = (LogBufferInfo *)slapi_ch_malloc(sizeof(LogBufferInfo));
     lbi->top = (char *)slapi_ch_malloc(sz);
     lbi->current = lbi->top;
     lbi->maxsize = sz;
-    slapi_atomic_store(&(lbi->refcount), &init_val, __ATOMIC_RELEASE, ATOMIC_LONG);
+    slapi_atomic_store_64(&(lbi->refcount), 0, __ATOMIC_RELEASE);
     return lbi;
 }
 
@@ -5010,7 +5009,7 @@ log_append_buffer2(time_t tnl, LogBufferInfo *lbi, char *msg1, size_t size1, cha
     insert_point = lbi->current;
     lbi->current += size;
     /* Increment the copy refcount */
-    slapi_atomic_incr(&(lbi->refcount), __ATOMIC_RELEASE, ATOMIC_LONG);
+    slapi_atomic_incr_64(&(lbi->refcount), __ATOMIC_RELEASE);
     PR_Unlock(lbi->lock);
 
     /* Now we can copy without holding the lock */
@@ -5018,7 +5017,7 @@ log_append_buffer2(time_t tnl, LogBufferInfo *lbi, char *msg1, size_t size1, cha
     memcpy(insert_point + size1, msg2, size2);
 
     /* Decrement the copy refcount */
-    slapi_atomic_decr(&(lbi->refcount), __ATOMIC_RELEASE, ATOMIC_LONG);
+    slapi_atomic_decr_64(&(lbi->refcount), __ATOMIC_RELEASE);
 
     /* If we are asked to sync to disk immediately, do so */
     if (!slapdFrontendConfig->accesslogbuffering) {
@@ -5038,7 +5037,7 @@ log_flush_buffer(LogBufferInfo *lbi, int type, int sync_now)
     if (type == SLAPD_ACCESS_LOG) {
 
         /* It is only safe to flush once any other threads which are copying are finished */
-        while (slapi_atomic_load(&(lbi->refcount), __ATOMIC_ACQUIRE, ATOMIC_LONG) > 0) {
+        while (slapi_atomic_load_64(&(lbi->refcount), __ATOMIC_ACQUIRE) > 0) {
             /* It's ok to sleep for a while because we only flush every second or so */
             DS_Sleep(PR_MillisecondsToInterval(1));
         }
diff --git a/ldap/servers/slapd/mapping_tree.c b/ldap/servers/slapd/mapping_tree.c
index 6621ceb..8cc5318 100644
--- a/ldap/servers/slapd/mapping_tree.c
+++ b/ldap/servers/slapd/mapping_tree.c
@@ -1647,7 +1647,7 @@ mapping_tree_init()
 
     /* we call this function from a single thread, so it should be ok */
 
-    if (slapi_atomic_load(&mapping_tree_freed, __ATOMIC_RELAXED, ATOMIC_INT)) {
+    if (slapi_atomic_load_32(&mapping_tree_freed, __ATOMIC_RELAXED)) {
         /* shutdown has been detected */
         return 0;
     }
@@ -1759,8 +1759,6 @@ mtn_free_node(mapping_tree_node **node)
 void
 mapping_tree_free()
 {
-    int init_val = 1;
-
     /* unregister dse callbacks */
     slapi_config_remove_callback(SLAPI_OPERATION_MODIFY, DSE_FLAG_PREOP, MAPPING_TREE_BASE_DN, LDAP_SCOPE_BASE, "(objectclass=*)", mapping_tree_entry_modify_callback);
     slapi_config_remove_callback(SLAPI_OPERATION_ADD, DSE_FLAG_PREOP, MAPPING_TREE_BASE_DN, LDAP_SCOPE_BASE, "(objectclass=*)", mapping_tree_entry_add_callback);
@@ -1773,7 +1771,7 @@ mapping_tree_free()
     slapi_unregister_backend_state_change_all();
     /* recursively free tree nodes */
     mtn_free_node(&mapping_tree_root);
-    slapi_atomic_store(&mapping_tree_freed, &init_val, __ATOMIC_RELAXED, ATOMIC_INT);
+    slapi_atomic_store_32(&mapping_tree_freed, 1, __ATOMIC_RELAXED);
 }
 
 /* This function returns the first node to parse when a search is done
@@ -2024,7 +2022,7 @@ slapi_dn_write_needs_referral(Slapi_DN *target_sdn, Slapi_Entry **referral)
     mapping_tree_node *target_node = NULL;
     int ret = 0;
 
-    if (slapi_atomic_load(&mapping_tree_freed, __ATOMIC_RELAXED, ATOMIC_INT)) {
+    if (slapi_atomic_load_32(&mapping_tree_freed, __ATOMIC_RELAXED)) {
         /* shutdown detected */
         goto done;
     }
@@ -2095,7 +2093,7 @@ slapi_mapping_tree_select(Slapi_PBlock *pb, Slapi_Backend **be, Slapi_Entry **re
     int fixup = 0;
 
 
-    if (slapi_atomic_load(&mapping_tree_freed, __ATOMIC_RELAXED, ATOMIC_INT)) {
+    if (slapi_atomic_load_32(&mapping_tree_freed, __ATOMIC_RELAXED)) {
         /* shutdown detected */
         return LDAP_OPERATIONS_ERROR;
     }
@@ -2200,7 +2198,7 @@ slapi_mapping_tree_select_all(Slapi_PBlock *pb, Slapi_Backend **be_list, Slapi_E
     int flag_partial_result = 0;
     int op_type;
 
-    if (slapi_atomic_load(&mapping_tree_freed, __ATOMIC_RELAXED, ATOMIC_INT)) {
+    if (slapi_atomic_load_32(&mapping_tree_freed, __ATOMIC_RELAXED)) {
         return LDAP_OPERATIONS_ERROR;
     }
 
@@ -2360,7 +2358,7 @@ slapi_mapping_tree_select_and_check(Slapi_PBlock *pb, char *newdn, Slapi_Backend
     int ret;
     int need_unlock = 0;
 
-    if (slapi_atomic_load(&mapping_tree_freed, __ATOMIC_RELAXED, ATOMIC_INT)) {
+    if (slapi_atomic_load_32(&mapping_tree_freed, __ATOMIC_RELAXED)) {
         return LDAP_OPERATIONS_ERROR;
     }
 
@@ -2526,7 +2524,7 @@ mtn_get_be(mapping_tree_node *target_node, Slapi_PBlock *pb, Slapi_Backend **be,
     int flag_stop = 0;
     struct slapi_componentid *cid = NULL;
 
-    if (slapi_atomic_load(&mapping_tree_freed, __ATOMIC_RELAXED, ATOMIC_INT)) {
+    if (slapi_atomic_load_32(&mapping_tree_freed, __ATOMIC_RELAXED)) {
         /* shut down detected */
         return LDAP_OPERATIONS_ERROR;
     }
@@ -2714,7 +2712,7 @@ best_matching_child(mapping_tree_node *parent,
     mapping_tree_node *highest_match_node = NULL;
     mapping_tree_node *current;
 
-    if (slapi_atomic_load(&mapping_tree_freed, __ATOMIC_RELAXED, ATOMIC_INT)) {
+    if (slapi_atomic_load_32(&mapping_tree_freed, __ATOMIC_RELAXED)) {
         /* shutdown detected */
         return NULL;
     }
@@ -2741,7 +2739,7 @@ mtn_get_mapping_tree_node_by_entry(mapping_tree_node *node, const Slapi_DN *dn)
 {
     mapping_tree_node *found_node = NULL;
 
-    if (slapi_atomic_load(&mapping_tree_freed, __ATOMIC_RELAXED, ATOMIC_INT)) {
+    if (slapi_atomic_load_32(&mapping_tree_freed, __ATOMIC_RELAXED)) {
         /* shutdown detected */
         return NULL;
     }
@@ -2784,7 +2782,7 @@ slapi_get_mapping_tree_node_by_dn(const Slapi_DN *dn)
     mapping_tree_node *current_best_match = mapping_tree_root;
     mapping_tree_node *next_best_match = mapping_tree_root;
 
-    if (slapi_atomic_load(&mapping_tree_freed, __ATOMIC_RELAXED, ATOMIC_INT)) {
+    if (slapi_atomic_load_32(&mapping_tree_freed, __ATOMIC_RELAXED)) {
         /* shutdown detected */
         return NULL;
     }
@@ -2818,7 +2816,7 @@ get_mapping_tree_node_by_name(mapping_tree_node *node, char *be_name)
     int i;
     mapping_tree_node *found_node = NULL;
 
-    if (slapi_atomic_load(&mapping_tree_freed, __ATOMIC_RELAXED, ATOMIC_INT)) {
+    if (slapi_atomic_load_32(&mapping_tree_freed, __ATOMIC_RELAXED)) {
         /* shutdown detected */
         return NULL;
     }
@@ -2865,7 +2863,7 @@ slapi_get_mapping_tree_node_configdn(const Slapi_DN *root)
 {
     char *dn = NULL;
 
-    if (slapi_atomic_load(&mapping_tree_freed, __ATOMIC_RELAXED, ATOMIC_INT)) {
+    if (slapi_atomic_load_32(&mapping_tree_freed, __ATOMIC_RELAXED)) {
         /* shutdown detected */
         return NULL;
     }
@@ -2892,7 +2890,7 @@ slapi_get_mapping_tree_node_configsdn(const Slapi_DN *root)
     char *dn = NULL;
     Slapi_DN *sdn = NULL;
 
-    if (slapi_atomic_load(&mapping_tree_freed, __ATOMIC_RELAXED, ATOMIC_INT)) {
+    if (slapi_atomic_load_32(&mapping_tree_freed, __ATOMIC_RELAXED)) {
         /* shutdown detected */
         return NULL;
     }
diff --git a/ldap/servers/slapd/object.c b/ldap/servers/slapd/object.c
index 6a1a9a5..8e55a16 100644
--- a/ldap/servers/slapd/object.c
+++ b/ldap/servers/slapd/object.c
@@ -43,12 +43,11 @@ Object *
 object_new(void *user_data, FNFree destructor)
 {
     Object *o;
-    uint64_t init_val = 1;
 
     o = (object *)slapi_ch_malloc(sizeof(object));
     o->destructor = destructor;
     o->data = user_data;
-    slapi_atomic_store(&(o->refcnt), &init_val, __ATOMIC_RELEASE, ATOMIC_LONG);
+    slapi_atomic_store_64(&(o->refcnt), 1, __ATOMIC_RELEASE);
     return o;
 }
 
@@ -62,7 +61,7 @@ void
 object_acquire(Object *o)
 {
     PR_ASSERT(NULL != o);
-    slapi_atomic_incr(&(o->refcnt), __ATOMIC_RELEASE, ATOMIC_LONG);
+    slapi_atomic_incr_64(&(o->refcnt), __ATOMIC_RELEASE);
 }
 
 
@@ -77,7 +76,7 @@ object_release(Object *o)
     PRInt32 refcnt_after_release;
 
     PR_ASSERT(NULL != o);
-    refcnt_after_release = slapi_atomic_decr(&(o->refcnt), __ATOMIC_ACQ_REL, ATOMIC_LONG);
+    refcnt_after_release = slapi_atomic_decr_64(&(o->refcnt), __ATOMIC_ACQ_REL);
     if (refcnt_after_release == 0) {
         /* Object can be destroyed */
         if (o->destructor)
diff --git a/ldap/servers/slapd/psearch.c b/ldap/servers/slapd/psearch.c
index 70c530b..e0dd2bf 100644
--- a/ldap/servers/slapd/psearch.c
+++ b/ldap/servers/slapd/psearch.c
@@ -134,7 +134,7 @@ ps_stop_psearch_system()
     if (PS_IS_INITIALIZED()) {
         PSL_LOCK_WRITE();
         for (ps = psearch_list->pl_head; NULL != ps; ps = ps->ps_next) {
-            slapi_atomic_incr(&(ps->ps_complete), __ATOMIC_RELEASE, ATOMIC_LONG);
+            slapi_atomic_incr_64(&(ps->ps_complete), __ATOMIC_RELEASE);
         }
         PSL_UNLOCK_WRITE();
         ps_wakeup_all();
@@ -285,7 +285,7 @@ ps_send_results(void *arg)
 
     PR_Lock(psearch_list->pl_cvarlock);
 
-    while ((conn_acq_flag == 0) && slapi_atomic_load(&(ps->ps_complete), __ATOMIC_ACQUIRE, ATOMIC_LONG) == 0) {
+    while ((conn_acq_flag == 0) && slapi_atomic_load_64(&(ps->ps_complete), __ATOMIC_ACQUIRE) == 0) {
         /* Check for an abandoned operation */
         if (pb_op == NULL || slapi_op_abandoned(ps->ps_pblock)) {
             slapi_log_err(SLAPI_LOG_CONNS, "ps_send_results",
@@ -427,7 +427,6 @@ static PSearch *
 psearch_alloc(void)
 {
     PSearch *ps;
-    uint64_t init_val = 0;
 
     ps = (PSearch *)slapi_ch_calloc(1, sizeof(PSearch));
 
@@ -438,7 +437,7 @@ psearch_alloc(void)
         slapi_ch_free((void **)&ps);
         return (NULL);
     }
-    slapi_atomic_store(&(ps->ps_complete), &init_val, __ATOMIC_RELEASE, ATOMIC_LONG);
+    slapi_atomic_store_64(&(ps->ps_complete), 0, __ATOMIC_RELEASE);
     ps->ps_eq_head = ps->ps_eq_tail = (PSEQNode *)NULL;
     ps->ps_lasttime = (time_t)0L;
     ps->ps_next = NULL;
diff --git a/ldap/servers/slapd/slapi-plugin.h b/ldap/servers/slapd/slapi-plugin.h
index c434add..4566202 100644
--- a/ldap/servers/slapd/slapi-plugin.h
+++ b/ldap/servers/slapd/slapi-plugin.h
@@ -8202,56 +8202,87 @@ void slapi_operation_time_initiated(Slapi_Operation *o, struct timespec *initiat
  */
 #endif
 
-/* See: https://gcc.gnu.org/ml/gcc/2016-11/txt6ZlA_JS27i.txt */
-#define ATOMIC_GENERIC  0
-#define ATOMIC_INT      4
-#define ATOMIC_LONG     8
-#define ATOMIC_INT128  16  /* Future */
+/**
+ * Store a 32bit integral value atomicly
+ *
+ * \param ptr - integral pointer
+ * \param val - pointer to integral value (use integral type int32_t with ATOMIC_INT, or uint64_t
+ * with ATOMIC_LONG & ATOMIC_GENERIC)
+ * \param memorder - __ATOMIC_RELAXED, __ATOMIC_CONSUME, __ATOMIC_ACQUIRE,
+ * __ATOMIC_RELEASE, __ATOMIC_ACQ_REL, __ATOMIC_SEQ_CST
+ */
+void slapi_atomic_store_32(int32_t *ptr, int32_t val, int memorder);
 
 /**
- * Store an integral value atomicly
+ * Store a 64bit integral value atomicly
  *
  * \param ptr - integral pointer
  * \param val - pointer to integral value (use integral type int32_t with ATOMIC_INT, or uint64_t
  * with ATOMIC_LONG & ATOMIC_GENERIC)
  * \param memorder - __ATOMIC_RELAXED, __ATOMIC_CONSUME, __ATOMIC_ACQUIRE,
  * __ATOMIC_RELEASE, __ATOMIC_ACQ_REL, __ATOMIC_SEQ_CST
- * \param type - "ptr" type: ATOMIC_GENERIC, ATOMIC_INT, or ATOMIC_LONG
  */
-void slapi_atomic_store(void *ptr, void *val, int memorder, int type);
+void slapi_atomic_store_64(uint64_t *ptr, uint64_t val, int memorder);
 
 /**
- * Get an integral value atomicly
+ * Get a 32bit integral value atomicly
  *
  * \param ptr - integral pointer
  * \param memorder - __ATOMIC_RELAXED, __ATOMIC_CONSUME, __ATOMIC_ACQUIRE,
  * __ATOMIC_RELEASE, __ATOMIC_ACQ_REL, __ATOMIC_SEQ_CST
- * \param type - "ptr" type: ATOMIC_GENERIC, ATOMIC_INT, or ATOMIC_LONG
  * \return -
  */
-uint64_t slapi_atomic_load(void *ptr, int memorder, int type);
+int32_t slapi_atomic_load_32(int32_t *ptr, int memorder);
 
 /**
- * Increment integral atomicly
+ * Get a 64bit integral value atomicly
+ *
+ * \param ptr - integral pointer
+ * \param memorder - __ATOMIC_RELAXED, __ATOMIC_CONSUME, __ATOMIC_ACQUIRE,
+ * __ATOMIC_RELEASE, __ATOMIC_ACQ_REL, __ATOMIC_SEQ_CST
+ * \return ptr value
+ */
+uint64_t slapi_atomic_load_64(uint64_t *ptr, int memorder);
+
+/**
+ * Increment a 32bit integral atomicly
  *
  * \param ptr - pointer to integral to increment
  * \param memorder - __ATOMIC_RELAXED, __ATOMIC_CONSUME, __ATOMIC_ACQUIRE,
  * __ATOMIC_RELEASE, __ATOMIC_ACQ_REL, __ATOMIC_SEQ_CST
- * \param type - "ptr" type: ATOMIC_GENERIC, ATOMIC_INT, or ATOMIC_LONG
  * \return - new value of ptr
  */
-uint64_t slapi_atomic_incr(void *ptr, int memorder, int type);
+int32_t slapi_atomic_incr_32(int32_t *ptr, int memorder);
+
+/**
+ * Increment a 64bitintegral atomicly
+ *
+ * \param ptr - pointer to integral to increment
+ * \param memorder - __ATOMIC_RELAXED, __ATOMIC_CONSUME, __ATOMIC_ACQUIRE,
+ * __ATOMIC_RELEASE, __ATOMIC_ACQ_REL, __ATOMIC_SEQ_CST
+ * \return - new value of ptr
+ */
+uint64_t slapi_atomic_incr_64(uint64_t *ptr, int memorder);
+
+/**
+ * Decrement a 32bit integral atomicly
+ *
+ * \param ptr - pointer to integral to decrement
+ * \param memorder - __ATOMIC_RELAXED, __ATOMIC_CONSUME, __ATOMIC_ACQUIRE,
+ * __ATOMIC_RELEASE, __ATOMIC_ACQ_REL, __ATOMIC_SEQ_CST
+ * \return - new value of ptr
+ */
+int32_t slapi_atomic_decr_32(int32_t *ptr, int memorder);
 
 /**
- * Decrement integral atomicly
+ * Decrement a 64bitintegral atomicly
  *
  * \param ptr - pointer to integral to decrement
  * \param memorder - __ATOMIC_RELAXED, __ATOMIC_CONSUME, __ATOMIC_ACQUIRE,
  * __ATOMIC_RELEASE, __ATOMIC_ACQ_REL, __ATOMIC_SEQ_CST
- * \param type - "ptr" type: ATOMIC_GENERIC, ATOMIC_INT, or ATOMIC_LONG
  * \return - new value of ptr
  */
-uint64_t slapi_atomic_decr(void *ptr, int memorder, int type);
+uint64_t slapi_atomic_decr_64(uint64_t *ptr, int memorder);
 
 
 #ifdef __cplusplus
diff --git a/ldap/servers/slapd/slapi_counter.c b/ldap/servers/slapd/slapi_counter.c
index 9e705b3..c5cae27 100644
--- a/ldap/servers/slapd/slapi_counter.c
+++ b/ldap/servers/slapd/slapi_counter.c
@@ -295,53 +295,41 @@ slapi_counter_get_value(Slapi_Counter *counter)
  * __ATOMIC_RELEASE, __ATOMIC_ACQ_REL, or __ATOMIC_SEQ_CST
  *
  *     See: https://gcc.gnu.org/onlinedocs/gcc-4.9.2/gcc/_005f_005fatomic-Builtins.html
- *
- * type_size - ATOMIC_GENERIC, ATOMIC_INT, or ATOMIC_LONG, see slapi-plugin.h for more info
- *
- * Future:
- *    If we need to support ATOMIC_INT128 (not available on 32bit systems):
- *         __atomic_store_16((uint64_t *)&ptr, val, memorder);
- *         __atomic_load_16((uint64_t *)&ptr, memorder);
- *         __atomic_add_fetch_16((uint64_t *)&ptr, 1, memorder);
- *         __atomic_sub_fetch_16((uint64_t *)&ptr, 1, memorder);
  */
 
 /*
- * "val" must be either int32_t or uint64_t
+ * atomic store functions (32bit and 64bit)
  */
 void
-slapi_atomic_store(void *ptr, void *val, int memorder, int type_size)
+slapi_atomic_store_32(int32_t *ptr, int32_t val, int memorder)
 {
 #ifdef ATOMIC_64BIT_OPERATIONS
-    if (type_size == ATOMIC_INT) {
-        __atomic_store_4((int32_t *)ptr, *(int32_t *)val, memorder);
-    } else if (type_size == ATOMIC_LONG) {
-        __atomic_store_8((uint64_t *)ptr, *(uint64_t *)val, memorder);
-    } else {
-        /* ATOMIC_GENERIC or unknown size */
-        __atomic_store((uint64_t *)&ptr, (uint64_t *)val, memorder);
-    }
+    __atomic_store_4(ptr, val, memorder);
 #else
     PRInt32 *pr_ptr = (PRInt32 *)ptr;
-    PR_AtomicSet(pr_ptr, *(PRInt32 *)val);
+    PR_AtomicSet(pr_ptr, (PRInt32)val);
 #endif
 }
 
-uint64_t
-slapi_atomic_load(void *ptr, int memorder, int type_size)
+void
+slapi_atomic_store_64(uint64_t *ptr, uint64_t val, int memorder)
 {
 #ifdef ATOMIC_64BIT_OPERATIONS
-    uint64_t ret;
+    __atomic_store_8(ptr, val, memorder);
+#else
+    PRInt32 *pr_ptr = (PRInt32 *)ptr;
+    PR_AtomicSet(pr_ptr, (PRInt32)val);
+#endif
+}
 
-    if (type_size == ATOMIC_INT) {
-        return __atomic_load_4((int32_t *)ptr, memorder);
-    } else if (type_size == ATOMIC_LONG) {
-        return __atomic_load_8((uint64_t *)ptr, memorder);
-    } else {
-        /* ATOMIC_GENERIC or unknown size */
-        __atomic_load((uint64_t *)ptr, &ret, memorder);
-        return ret;
-    }
+/*
+ * atomic load functions (32bit and 64bit)
+ */
+int32_t
+slapi_atomic_load_32(int32_t *ptr, int memorder)
+{
+#ifdef ATOMIC_64BIT_OPERATIONS
+    return __atomic_load_4(ptr, memorder);
 #else
     PRInt32 *pr_ptr = (PRInt32 *)ptr;
     return PR_AtomicAdd(pr_ptr, 0);
@@ -349,17 +337,24 @@ slapi_atomic_load(void *ptr, int memorder, int type_size)
 }
 
 uint64_t
-slapi_atomic_incr(void *ptr, int memorder, int type_size)
+slapi_atomic_load_64(uint64_t *ptr, int memorder)
 {
 #ifdef ATOMIC_64BIT_OPERATIONS
-    if (type_size == ATOMIC_INT) {
-        return __atomic_add_fetch_4((int32_t *)ptr, 1, memorder);
-    } else if (type_size == ATOMIC_LONG) {
-        return __atomic_add_fetch_8((uint64_t *)ptr, 1, memorder);
-    } else {
-        /* ATOMIC_GENERIC or unknown size */
-        return __atomic_add_fetch((uint64_t *)ptr, 1, memorder);
-    }
+    return __atomic_load_8(ptr, memorder);
+#else
+    PRInt32 *pr_ptr = (PRInt32 *)ptr;
+    return PR_AtomicAdd(pr_ptr, 0);
+#endif
+}
+
+/*
+ * atomic increment functions (32bit and 64bit)
+ */
+int32_t
+slapi_atomic_incr_32(int32_t *ptr, int memorder)
+{
+#ifdef ATOMIC_64BIT_OPERATIONS
+    return __atomic_add_fetch_4(ptr, 1, memorder);
 #else
     PRInt32 *pr_ptr = (PRInt32 *)ptr;
     return PR_AtomicIncrement(pr_ptr);
@@ -367,17 +362,35 @@ slapi_atomic_incr(void *ptr, int memorder, int type_size)
 }
 
 uint64_t
-slapi_atomic_decr(void *ptr, int memorder, int type_size)
+slapi_atomic_incr_64(uint64_t *ptr, int memorder)
 {
 #ifdef ATOMIC_64BIT_OPERATIONS
-    if (type_size == ATOMIC_INT) {
-        return __atomic_sub_fetch_4((int32_t *)ptr, 1, memorder);
-    } else if (type_size == ATOMIC_LONG) {
-        return __atomic_sub_fetch_8((uint64_t *)ptr, 1, memorder);
-    } else {
-        /* ATOMIC_GENERIC or unknown size */
-        return __atomic_sub_fetch((uint64_t *)ptr, 1, memorder);
-    }
+    return __atomic_add_fetch_8(ptr, 1, memorder);
+#else
+    PRInt32 *pr_ptr = (PRInt32 *)ptr;
+    return PR_AtomicIncrement(pr_ptr);
+#endif
+}
+
+/*
+ * atomic decrement functions (32bit and 64bit)
+ */
+int32_t
+slapi_atomic_decr_32(int32_t *ptr, int memorder)
+{
+#ifdef ATOMIC_64BIT_OPERATIONS
+    return __atomic_sub_fetch_4(ptr, 1, memorder);
+#else
+    PRInt32 *pr_ptr = (PRInt32 *)ptr;
+    return PR_AtomicDecrement(pr_ptr);
+#endif
+}
+
+uint64_t
+slapi_atomic_decr_64(uint64_t *ptr, int memorder)
+{
+#ifdef ATOMIC_64BIT_OPERATIONS
+    return __atomic_sub_fetch_8(ptr, 1, memorder);
 #else
     PRInt32 *pr_ptr = (PRInt32 *)ptr;
     return PR_AtomicDecrement(pr_ptr);
-- 
2.9.5

