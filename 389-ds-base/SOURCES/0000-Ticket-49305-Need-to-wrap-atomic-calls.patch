From f19dec383e24e2aaa40a6bdce2ca0e657ffc6e10 Mon Sep 17 00:00:00 2001
From: Mark Reynolds <mreynolds@redhat.com>
Date: Wed, 27 Sep 2017 09:26:14 -0400
Subject: [PATCH] Ticket 49305 - Need to wrap atomic calls

Bug Description:  Some RHEL 7.5 platforms (ppc 32bit) still do not support
                  all the gcc builtin atomics.  This breaks the downstream
                  builds.

Fix Description:  Use wrapper functions for the atomic's using #define's
                  to detect if builtin atomics are supported, otherwise
                  use the egneric nspr atomic functions.

https://pagure.io/389-ds-base/issue/49305

Reviewed by: tbordaz(Thanks!)

(cherry picked from commit af723fd632d355642babeed1dbdb5a308c21fa79)
---
 ldap/servers/slapd/attrsyntax.c                  |   8 +-
 ldap/servers/slapd/back-ldbm/dblayer.c           |  66 +++++-----
 ldap/servers/slapd/entry.c                       |  11 +-
 ldap/servers/slapd/libglobs.c                    | 161 ++++++++++++-----------
 ldap/servers/slapd/log.c                         |   9 +-
 ldap/servers/slapd/mapping_tree.c                |  28 ++--
 ldap/servers/slapd/object.c                      |   8 +-
 ldap/servers/slapd/psearch.c                     |   7 +-
 ldap/servers/slapd/slapi-plugin.h                |  52 ++++++++
 ldap/servers/slapd/slapi_counter.c               | 100 ++++++++++++++
 ldap/servers/slapd/thread_data.c                 |   2 +-
 src/nunc-stans/ns/ns_thrpool.c                   |  17 ++-
 src/nunc-stans/test/test_nuncstans_stress_core.c |  42 +++++-
 13 files changed, 361 insertions(+), 150 deletions(-)

diff --git a/ldap/servers/slapd/attrsyntax.c b/ldap/servers/slapd/attrsyntax.c
index 03f05d9..a0a60c4 100644
--- a/ldap/servers/slapd/attrsyntax.c
+++ b/ldap/servers/slapd/attrsyntax.c
@@ -274,7 +274,7 @@ attr_syntax_get_by_oid_locking_optional(const char *oid, PRBool use_lock, PRUint
         }
         asi = (struct asyntaxinfo *)PL_HashTableLookup_const(ht, oid);
         if (asi) {
-            __atomic_add_fetch_8(&(asi->asi_refcnt), 1, __ATOMIC_RELEASE);
+            slapi_atomic_incr(&(asi->asi_refcnt), __ATOMIC_RELEASE, ATOMIC_LONG);
         }
         if (use_lock) {
             AS_UNLOCK_READ(oid2asi_lock);
@@ -371,7 +371,7 @@ attr_syntax_get_by_name_locking_optional(const char *name, PRBool use_lock, PRUi
         }
         asi = (struct asyntaxinfo *)PL_HashTableLookup_const(ht, name);
         if (NULL != asi) {
-            __atomic_add_fetch_8(&(asi->asi_refcnt), 1, __ATOMIC_RELEASE);
+            slapi_atomic_incr(&(asi->asi_refcnt), __ATOMIC_RELEASE, ATOMIC_LONG);
         }
         if (use_lock) {
             AS_UNLOCK_READ(name2asi_lock);
@@ -406,7 +406,7 @@ attr_syntax_return_locking_optional(struct asyntaxinfo *asi, PRBool use_lock)
     }
     if (NULL != asi) {
         PRBool delete_it = PR_FALSE;
-        if (0 == __atomic_sub_fetch_8(&(asi->asi_refcnt), 1, __ATOMIC_ACQ_REL)) {
+        if (0 == slapi_atomic_decr(&(asi->asi_refcnt), __ATOMIC_ACQ_REL, ATOMIC_LONG)) {
             delete_it = asi->asi_marked_for_delete;
         }
 
@@ -540,7 +540,7 @@ attr_syntax_delete_no_lock(struct asyntaxinfo *asi,
                 PL_HashTableRemove(ht, asi->asi_aliases[i]);
             }
         }
-        if (__atomic_load_8(&(asi->asi_refcnt), __ATOMIC_ACQUIRE) > 0) {
+        if (slapi_atomic_load(&(asi->asi_refcnt), __ATOMIC_ACQUIRE, ATOMIC_LONG) > 0) {
             asi->asi_marked_for_delete = PR_TRUE;
         } else {
             /* This is ok, but the correct thing is to call delete first,
diff --git a/ldap/servers/slapd/back-ldbm/dblayer.c b/ldap/servers/slapd/back-ldbm/dblayer.c
index d43258d..c4c4959 100644
--- a/ldap/servers/slapd/back-ldbm/dblayer.c
+++ b/ldap/servers/slapd/back-ldbm/dblayer.c
@@ -2860,16 +2860,16 @@ int
 dblayer_get_index_file(backend *be, struct attrinfo *a, DB **ppDB, int open_flags)
 {
     /*
-   * We either already have a DB* handle in the attrinfo structure.
-   * in which case we simply return it to the caller, OR:
-   * we need to make one. We do this as follows:
-   * 1a) acquire the mutex that protects the handle list.
-   * 1b) check that the DB* is still null.
-   * 2) get the filename, and call libdb to open it
-   * 3) if successful, store the result in the attrinfo stucture
-   * 4) store the DB* in our own list so we can close it later.
-   * 5) release the mutex.
-   */
+     * We either already have a DB* handle in the attrinfo structure.
+     * in which case we simply return it to the caller, OR:
+     * we need to make one. We do this as follows:
+     * 1a) acquire the mutex that protects the handle list.
+     * 1b) check that the DB* is still null.
+     * 2) get the filename, and call libdb to open it
+     * 3) if successful, store the result in the attrinfo stucture
+     * 4) store the DB* in our own list so we can close it later.
+     * 5) release the mutex.
+     */
     ldbm_instance *inst = (ldbm_instance *)be->be_instance_info;
     int return_value = -1;
     DB *pDB = NULL;
@@ -2878,9 +2878,9 @@ dblayer_get_index_file(backend *be, struct attrinfo *a, DB **ppDB, int open_flag
     *ppDB = NULL;
 
     /* it's like a semaphore -- when count > 0, any file handle that's in
-   * the attrinfo will remain valid from here on.
-   */
-    __atomic_add_fetch_8(&(a->ai_dblayer_count), 1, __ATOMIC_RELEASE);
+     * the attrinfo will remain valid from here on.
+     */
+    slapi_atomic_incr(&(a->ai_dblayer_count), __ATOMIC_RELEASE, ATOMIC_LONG);
 
     if (a->ai_dblayer && ((dblayer_handle *)(a->ai_dblayer))->dblayer_dbp) {
         /* This means that the pointer is valid, so we should return it. */
@@ -2888,9 +2888,7 @@ dblayer_get_index_file(backend *be, struct attrinfo *a, DB **ppDB, int open_flag
         return 0;
     }
 
-    /* attrinfo handle is NULL, at least for now -- grab the mutex and try
-   * again.
-   */
+    /* attrinfo handle is NULL, at least for now -- grab the mutex and try again. */
     PR_Lock(inst->inst_handle_list_mutex);
     if (a->ai_dblayer && ((dblayer_handle *)(a->ai_dblayer))->dblayer_dbp) {
         /* another thread set the handle while we were waiting on the lock */
@@ -2900,8 +2898,8 @@ dblayer_get_index_file(backend *be, struct attrinfo *a, DB **ppDB, int open_flag
     }
 
     /* attrinfo handle is still blank, and we have the mutex: open the
-   * index file and stuff it in the attrinfo.
-   */
+     * index file and stuff it in the attrinfo.
+     */
     return_value = dblayer_open_file(be, attribute_name, open_flags,
                                      a, &pDB);
     if (0 == return_value) {
@@ -2911,40 +2909,36 @@ dblayer_get_index_file(backend *be, struct attrinfo *a, DB **ppDB, int open_flag
 
         PR_ASSERT(NULL != pDB);
         /* Store the returned DB* in our own private list of
-       * open files */
+         * open files */
         if (NULL == prev_handle) {
             /* List was empty */
             inst->inst_handle_tail = handle;
             inst->inst_handle_head = handle;
         } else {
-            /* Chain the handle onto the last structure in the
-           * list */
+            /* Chain the handle onto the last structure in the list */
             inst->inst_handle_tail = handle;
             prev_handle->dblayer_handle_next = handle;
         }
-        /* Stash a pointer to our wrapper structure in the
-       * attrinfo structure */
+        /* Stash a pointer to our wrapper structure in the attrinfo structure */
         handle->dblayer_dbp = pDB;
         /* And, most importantly, return something to the caller!*/
         *ppDB = pDB;
-        /* and save the hande in the attrinfo structure for
-       * next time */
+        /* and save the hande in the attrinfo structure for next time */
         a->ai_dblayer = handle;
         /* don't need to update count -- we incr'd it already */
         handle->dblayer_handle_ai_backpointer = &(a->ai_dblayer);
     } else {
         /* Did not open it OK ! */
         /* Do nothing, because return value and fact that we didn't
-     * store a DB* in the attrinfo is enough
-     */
+         * store a DB* in the attrinfo is enough */
     }
     PR_Unlock(inst->inst_handle_list_mutex);
 
     if (return_value != 0) {
         /* some sort of error -- we didn't open a handle at all.
-     * decrement the refcount back to where it was.
-     */
-        __atomic_sub_fetch_8(&(a->ai_dblayer_count), 1, __ATOMIC_RELEASE);
+         * decrement the refcount back to where it was.
+         */
+        slapi_atomic_decr(&(a->ai_dblayer_count), __ATOMIC_RELEASE, ATOMIC_LONG);
     }
 
     return return_value;
@@ -2956,7 +2950,7 @@ dblayer_get_index_file(backend *be, struct attrinfo *a, DB **ppDB, int open_flag
 int
 dblayer_release_index_file(backend *be __attribute__((unused)), struct attrinfo *a, DB *pDB __attribute__((unused)))
 {
-    __atomic_sub_fetch_8(&(a->ai_dblayer_count), 1, __ATOMIC_RELEASE);
+    slapi_atomic_decr(&(a->ai_dblayer_count), __ATOMIC_RELEASE, ATOMIC_LONG);
     return 0;
 }
 
@@ -3063,13 +3057,13 @@ dblayer_erase_index_file_ex(backend *be, struct attrinfo *a, PRBool use_lock, in
 
             dblayer_release_index_file(be, a, db);
 
-            while (__atomic_load_8(&(a->ai_dblayer_count), __ATOMIC_ACQUIRE) > 0) {
+            while (slapi_atomic_load(&(a->ai_dblayer_count), __ATOMIC_ACQUIRE, ATOMIC_LONG) > 0) {
                 /* someone is using this index file */
                 /* ASSUMPTION: you have already set the INDEX_OFFLINE flag, because
-         * you intend to mess with this index.  therefore no new requests
-         * for this indexfile should happen, so the dblayer_count should
-         * NEVER increase.
-         */
+                 * you intend to mess with this index.  therefore no new requests
+                 * for this indexfile should happen, so the dblayer_count should
+                 * NEVER increase.
+                 */
                 PR_ASSERT(a->ai_indexmask & INDEX_OFFLINE);
                 PR_Unlock(inst->inst_handle_list_mutex);
                 DS_Sleep(DBLAYER_CACHE_DELAY);
diff --git a/ldap/servers/slapd/entry.c b/ldap/servers/slapd/entry.c
index 62d10c2..289a149 100644
--- a/ldap/servers/slapd/entry.c
+++ b/ldap/servers/slapd/entry.c
@@ -2244,18 +2244,19 @@ slapi_entry_attr_find(const Slapi_Entry *e, const char *type, Slapi_Attr **a)
 
 /* the following functions control virtual attribute cache invalidation */
 
-static uint32_t g_virtual_watermark = 0; /* good enough to init */
+static int32_t g_virtual_watermark = 0; /* good enough to init */
 
 int
 slapi_entry_vattrcache_watermark_isvalid(const Slapi_Entry *e)
 {
-    return e->e_virtual_watermark == __atomic_load_4(&g_virtual_watermark, __ATOMIC_ACQUIRE);
+    return e->e_virtual_watermark == slapi_atomic_load(&g_virtual_watermark, __ATOMIC_ACQUIRE, ATOMIC_INT);
+
 }
 
 void
 slapi_entry_vattrcache_watermark_set(Slapi_Entry *e)
 {
-    e->e_virtual_watermark = __atomic_load_4(&g_virtual_watermark, __ATOMIC_ACQUIRE);
+    e->e_virtual_watermark = slapi_atomic_load(&g_virtual_watermark, __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 void
@@ -2268,8 +2269,8 @@ void
 slapi_entrycache_vattrcache_watermark_invalidate()
 {
     /* Make sure the value is never 0 */
-    if (__atomic_add_fetch_4(&g_virtual_watermark, 1, __ATOMIC_RELEASE) == 0) {
-        __atomic_add_fetch_4(&g_virtual_watermark, 1, __ATOMIC_RELEASE);
+    if (slapi_atomic_incr(&g_virtual_watermark, __ATOMIC_RELEASE, ATOMIC_INT) == 0) {
+        slapi_atomic_incr(&g_virtual_watermark, __ATOMIC_RELEASE, ATOMIC_INT);
     }
 }
 
diff --git a/ldap/servers/slapd/libglobs.c b/ldap/servers/slapd/libglobs.c
index 0eeb16a..4c54cf7 100644
--- a/ldap/servers/slapd/libglobs.c
+++ b/ldap/servers/slapd/libglobs.c
@@ -1335,19 +1335,19 @@ static uint64_t active_threads = 0;
 void
 g_incr_active_threadcnt(void)
 {
-    __atomic_add_fetch_8(&active_threads, 1, __ATOMIC_RELEASE);
+    slapi_atomic_incr(&active_threads, __ATOMIC_RELEASE, ATOMIC_LONG);
 }
 
 void
 g_decr_active_threadcnt(void)
 {
-    __atomic_sub_fetch_8(&active_threads, 1, __ATOMIC_RELEASE);
+    slapi_atomic_decr(&active_threads, __ATOMIC_RELEASE, ATOMIC_LONG);
 }
 
 uint64_t
 g_get_active_threadcnt(void)
 {
-    return __atomic_load_8(&active_threads, __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&active_threads, __ATOMIC_RELEASE, ATOMIC_LONG);
 }
 
 /*
@@ -1936,7 +1936,7 @@ config_set_ndn_cache_max_size(const char *attrname, char *value, char *errorbuf,
         size = NDN_DEFAULT_SIZE;
     }
     if (apply) {
-        __atomic_store_8(&(slapdFrontendConfig->ndn_cache_max_size), size, __ATOMIC_RELEASE);
+        slapi_atomic_store(&(slapdFrontendConfig->ndn_cache_max_size), &size, __ATOMIC_RELEASE, ATOMIC_LONG);
     }
 
     return retVal;
@@ -3476,7 +3476,8 @@ int32_t
 config_get_dynamic_plugins(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->dynamic_plugins), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->dynamic_plugins), __ATOMIC_ACQUIRE, ATOMIC_INT);
+
 }
 
 int32_t
@@ -3498,7 +3499,7 @@ int32_t
 config_get_cn_uses_dn_syntax_in_dns()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->cn_uses_dn_syntax_in_dns), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->cn_uses_dn_syntax_in_dns), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
@@ -3543,7 +3544,7 @@ config_set_onoff(const char *attrname, char *value, int32_t *configvalue, char *
         newval = LDAP_OFF;
     }
 
-    __atomic_store_4(configvalue, newval, __ATOMIC_RELEASE);
+    slapi_atomic_store(configvalue, &newval, __ATOMIC_RELEASE, ATOMIC_INT);
 
     return retVal;
 }
@@ -3915,7 +3916,7 @@ config_set_threadnumber(const char *attrname, char *value, char *errorbuf, int a
         retVal = LDAP_OPERATIONS_ERROR;
     }
     if (apply) {
-        __atomic_store_4(&(slapdFrontendConfig->threadnumber), threadnum, __ATOMIC_RELAXED);
+        slapi_atomic_store(&(slapdFrontendConfig->threadnumber), &threadnum, __ATOMIC_RELAXED, ATOMIC_INT);
     }
     return retVal;
 }
@@ -3944,7 +3945,7 @@ config_set_maxthreadsperconn(const char *attrname, char *value, char *errorbuf,
     }
 
     if (apply) {
-        __atomic_store_4(&(slapdFrontendConfig->maxthreadsperconn), maxthreadnum, __ATOMIC_RELEASE);
+        slapi_atomic_store(&(slapdFrontendConfig->maxthreadsperconn), &maxthreadnum, __ATOMIC_RELEASE, ATOMIC_INT);
     }
     return retVal;
 }
@@ -4102,7 +4103,7 @@ config_set_ioblocktimeout(const char *attrname, char *value, char *errorbuf, int
     }
 
     if (apply) {
-        __atomic_store_4(&(slapdFrontendConfig->ioblocktimeout), nValue, __ATOMIC_RELEASE);
+        slapi_atomic_store(&(slapdFrontendConfig->ioblocktimeout), &nValue, __ATOMIC_RELEASE, ATOMIC_INT);
     }
     return retVal;
 }
@@ -4606,21 +4607,22 @@ int32_t
 config_get_sasl_mapping_fallback()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->sasl_mapping_fallback), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->sasl_mapping_fallback), __ATOMIC_ACQUIRE, ATOMIC_INT);
+
 }
 
 int32_t
 config_get_disk_monitoring()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->disk_monitoring), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->disk_monitoring), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
 config_get_disk_logging_critical()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->disk_logging_critical), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->disk_logging_critical), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int
@@ -4667,14 +4669,14 @@ int32_t
 config_get_ldapi_switch()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->ldapi_switch), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->ldapi_switch), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
 config_get_ldapi_bind_switch()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->ldapi_bind_switch), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->ldapi_bind_switch), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 char *
@@ -4693,7 +4695,7 @@ int
 config_get_ldapi_map_entries()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->ldapi_map_entries), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->ldapi_map_entries), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 char *
@@ -4763,7 +4765,8 @@ int32_t
 config_get_slapi_counters()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->slapi_counters), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->slapi_counters), __ATOMIC_ACQUIRE, ATOMIC_INT);
+
 }
 
 char *
@@ -4945,7 +4948,7 @@ int32_t
 config_get_pw_change(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->pw_policy.pw_change), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->pw_policy.pw_change), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 
@@ -4953,7 +4956,7 @@ int32_t
 config_get_pw_history(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->pw_policy.pw_history), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->pw_policy.pw_history), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 
@@ -4961,21 +4964,21 @@ int32_t
 config_get_pw_must_change(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->pw_policy.pw_must_change), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->pw_policy.pw_must_change), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
 config_get_allow_hashed_pw(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->allow_hashed_pw), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->allow_hashed_pw), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
 config_get_pw_syntax(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->pw_policy.pw_syntax), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->pw_policy.pw_syntax), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 
@@ -5164,21 +5167,21 @@ int32_t
 config_get_pw_is_global_policy(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->pw_is_global_policy), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->pw_is_global_policy), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
 config_get_pw_is_legacy_policy(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->pw_policy.pw_is_legacy), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->pw_policy.pw_is_legacy), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
 config_get_pw_exp(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->pw_policy.pw_exp), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->pw_policy.pw_exp), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 
@@ -5186,14 +5189,14 @@ int32_t
 config_get_pw_unlock(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->pw_policy.pw_unlock), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->pw_policy.pw_unlock), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
 config_get_pw_lockout()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->pw_policy.pw_lockout), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->pw_policy.pw_lockout), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int
@@ -5213,112 +5216,112 @@ int32_t
 config_get_lastmod()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->lastmod), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->lastmod), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
 config_get_enquote_sup_oc()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->enquote_sup_oc), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->enquote_sup_oc), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
 config_get_nagle(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->nagle), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->nagle), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
 config_get_accesscontrol(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->accesscontrol), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->accesscontrol), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
 config_get_return_exact_case(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->return_exact_case), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->return_exact_case), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
 config_get_result_tweak(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->result_tweak), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->result_tweak), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
 config_get_moddn_aci(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->moddn_aci), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->moddn_aci), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
 config_get_security(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->security), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->security), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
 slapi_config_get_readonly(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->readonly), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->readonly), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
 config_get_schemacheck(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->schemacheck), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->schemacheck), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
 config_get_schemamod(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->schemamod), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->schemamod), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
 config_get_syntaxcheck(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->syntaxcheck), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->syntaxcheck), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
 config_get_syntaxlogging(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->syntaxlogging), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->syntaxlogging), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
 config_get_dn_validate_strict(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->dn_validate_strict), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->dn_validate_strict), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
 config_get_ds4_compatible_schema(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->ds4_compatible_schema), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->ds4_compatible_schema), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
 config_get_schema_ignore_trailing_spaces(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->schema_ignore_trailing_spaces), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->schema_ignore_trailing_spaces), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 char *
@@ -5402,7 +5405,7 @@ config_get_threadnumber(void)
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
     int32_t retVal;
 
-    retVal = __atomic_load_4(&(slapdFrontendConfig->threadnumber), __ATOMIC_RELAXED);
+    retVal = slapi_atomic_load(&(slapdFrontendConfig->threadnumber), __ATOMIC_RELAXED, ATOMIC_INT);
 
     if (retVal <= 0) {
         retVal = util_get_hardware_threads();
@@ -5420,7 +5423,7 @@ int32_t
 config_get_maxthreadsperconn()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->maxthreadsperconn), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->maxthreadsperconn), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int
@@ -5452,7 +5455,7 @@ int32_t
 config_get_ioblocktimeout()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->ioblocktimeout), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->ioblocktimeout), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int
@@ -5769,21 +5772,21 @@ int32_t
 config_get_unauth_binds_switch(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->allow_unauth_binds), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->allow_unauth_binds), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
 config_get_require_secure_binds(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->require_secure_binds), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->require_secure_binds), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
 config_get_anon_access_switch(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->allow_anon_access), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->allow_anon_access), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int
@@ -6025,7 +6028,8 @@ int32_t
 config_get_minssf_exclude_rootdse()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->minssf_exclude_rootdse), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->minssf_exclude_rootdse), __ATOMIC_ACQUIRE, ATOMIC_INT);
+
 }
 
 int
@@ -6034,18 +6038,17 @@ config_set_max_filter_nest_level(const char *attrname, char *value, char *errorb
     int retVal = LDAP_SUCCESS;
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
     char *endp;
-    long level;
+    int32_t level;
 
     if (config_value_is_null(attrname, value, errorbuf, 0)) {
         return LDAP_OPERATIONS_ERROR;
     }
 
     errno = 0;
-    level = strtol(value, &endp, 10);
+    level = (int32_t)strtol(value, &endp, 10);
     if (*endp != '\0' || errno == ERANGE) {
-        slapi_create_errormsg(errorbuf, SLAPI_DSE_RETURNTEXT_SIZE, "(%s) value (%s) "
-                                                                   "is invalid\n",
-                              attrname, value);
+        slapi_create_errormsg(errorbuf, SLAPI_DSE_RETURNTEXT_SIZE,
+                              "(%s) value (%s) is invalid\n", attrname, value);
         retVal = LDAP_OPERATIONS_ERROR;
         return retVal;
     }
@@ -6054,7 +6057,7 @@ config_set_max_filter_nest_level(const char *attrname, char *value, char *errorb
         return retVal;
     }
 
-    __atomic_store_4(&(slapdFrontendConfig->max_filter_nest_level), level, __ATOMIC_RELEASE);
+    slapi_atomic_store(&(slapdFrontendConfig->max_filter_nest_level), &level, __ATOMIC_RELEASE, ATOMIC_INT);
     return retVal;
 }
 
@@ -6062,29 +6065,28 @@ int32_t
 config_get_max_filter_nest_level()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->max_filter_nest_level), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->max_filter_nest_level), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 uint64_t
 config_get_ndn_cache_size()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-
-    return __atomic_load_8(&(slapdFrontendConfig->ndn_cache_max_size), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->ndn_cache_max_size), __ATOMIC_ACQUIRE, ATOMIC_LONG);
 }
 
 int32_t
 config_get_ndn_cache_enabled()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->ndn_cache_enabled), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->ndn_cache_enabled), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
 config_get_return_orig_type_switch()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->return_orig_type), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->return_orig_type), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 char *
@@ -6786,7 +6788,7 @@ int32_t
 config_get_force_sasl_external(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->force_sasl_external), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->force_sasl_external), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
@@ -6808,7 +6810,7 @@ int32_t
 config_get_entryusn_global(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->entryusn_global), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->entryusn_global), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
@@ -7046,21 +7048,21 @@ int32_t
 config_get_enable_turbo_mode(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->enable_turbo_mode), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->enable_turbo_mode), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
 config_get_connection_nocanon(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->connection_nocanon), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->connection_nocanon), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
 config_get_plugin_logging(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->plugin_logging), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->plugin_logging), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
@@ -7073,21 +7075,21 @@ int32_t
 config_get_unhashed_pw_switch()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->unhashed_pw_switch), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->unhashed_pw_switch), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
 config_get_ignore_time_skew(void)
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->ignore_time_skew), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->ignore_time_skew), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
 config_get_global_backend_lock()
 {
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
-    return __atomic_load_4(&(slapdFrontendConfig->global_backend_lock), __ATOMIC_ACQUIRE);
+    return slapi_atomic_load(&(slapdFrontendConfig->global_backend_lock), __ATOMIC_ACQUIRE, ATOMIC_INT);
 }
 
 int32_t
@@ -7163,8 +7165,9 @@ config_get_connection_buffer(void)
 int
 config_set_connection_buffer(const char *attrname, char *value, char *errorbuf, int apply)
 {
-    int retVal = LDAP_SUCCESS;
     slapdFrontendConfig_t *slapdFrontendConfig = getFrontendConfig();
+    int retVal = LDAP_SUCCESS;
+    int32_t val;
 
     if (config_value_is_null(attrname, value, errorbuf, 0)) {
         return LDAP_OPERATIONS_ERROR;
@@ -7181,7 +7184,9 @@ config_set_connection_buffer(const char *attrname, char *value, char *errorbuf,
         return retVal;
     }
 
-    __atomic_store_4(&(slapdFrontendConfig->connection_buffer), atoi(value), __ATOMIC_RELEASE);
+    val = atoi(value);
+    slapi_atomic_store(&(slapdFrontendConfig->connection_buffer), &val, __ATOMIC_RELEASE, ATOMIC_INT);
+
     return retVal;
 }
 
@@ -7204,7 +7209,7 @@ config_set_listen_backlog_size(const char *attrname, char *value, char *errorbuf
     }
 
     if (apply) {
-        __atomic_store_4(&(slapdFrontendConfig->listen_backlog_size), size, __ATOMIC_RELEASE);
+        slapi_atomic_store(&(slapdFrontendConfig->listen_backlog_size), &size, __ATOMIC_RELEASE, ATOMIC_INT);
     }
     return LDAP_SUCCESS;
 }
@@ -7617,7 +7622,7 @@ config_set_accesslog_enabled(int value)
     char errorbuf[SLAPI_DSE_RETURNTEXT_SIZE];
     errorbuf[0] = '\0';
 
-    __atomic_store_4(&(slapdFrontendConfig->accesslog_logging_enabled), value, __ATOMIC_RELEASE);
+    slapi_atomic_store(&(slapdFrontendConfig->accesslog_logging_enabled), &value, __ATOMIC_RELEASE, ATOMIC_INT);
     if (value) {
         log_set_logging(CONFIG_ACCESSLOG_LOGGING_ENABLED_ATTRIBUTE, "on", SLAPD_ACCESS_LOG, errorbuf, CONFIG_APPLY);
     } else {
@@ -7635,7 +7640,7 @@ config_set_auditlog_enabled(int value)
     char errorbuf[SLAPI_DSE_RETURNTEXT_SIZE];
     errorbuf[0] = '\0';
 
-    __atomic_store_4(&(slapdFrontendConfig->auditlog_logging_enabled), value, __ATOMIC_RELEASE);
+    slapi_atomic_store(&(slapdFrontendConfig->auditlog_logging_enabled), &value, __ATOMIC_RELEASE, ATOMIC_INT);
     if (value) {
         log_set_logging(CONFIG_AUDITLOG_LOGGING_ENABLED_ATTRIBUTE, "on", SLAPD_AUDIT_LOG, errorbuf, CONFIG_APPLY);
     } else {
@@ -7653,7 +7658,7 @@ config_set_auditfaillog_enabled(int value)
     char errorbuf[SLAPI_DSE_RETURNTEXT_SIZE];
     errorbuf[0] = '\0';
 
-    __atomic_store_4(&(slapdFrontendConfig->auditfaillog_logging_enabled), value, __ATOMIC_RELEASE);
+    slapi_atomic_store(&(slapdFrontendConfig->auditfaillog_logging_enabled), &value, __ATOMIC_RELEASE, ATOMIC_INT);
     if (value) {
         log_set_logging(CONFIG_AUDITFAILLOG_LOGGING_ENABLED_ATTRIBUTE, "on", SLAPD_AUDITFAIL_LOG, errorbuf, CONFIG_APPLY);
     } else {
@@ -7744,7 +7749,7 @@ config_set_malloc_mxfast(const char *attrname, char *value, char *errorbuf, int
                               value, CONFIG_MALLOC_MXFAST, max);
         return LDAP_OPERATIONS_ERROR;
     }
-    __atomic_store_4(&(slapdFrontendConfig->malloc_mxfast), mxfast, __ATOMIC_RELEASE);
+    slapi_atomic_store(&(slapdFrontendConfig->malloc_mxfast), &mxfast, __ATOMIC_RELEASE, ATOMIC_INT);
 
     if ((mxfast >= 0) && (mxfast <= max)) {
         mallopt(M_MXFAST, mxfast);
@@ -7784,7 +7789,7 @@ config_set_malloc_trim_threshold(const char *attrname, char *value, char *errorb
         return LDAP_OPERATIONS_ERROR;
     }
 
-    __atomic_store_4(&(slapdFrontendConfig->malloc_trim_threshold), trim_threshold, __ATOMIC_RELEASE);
+    slapi_atomic_store(&(slapdFrontendConfig->malloc_trim_threshold), &trim_threshold, __ATOMIC_RELEASE, ATOMIC_INT);
 
     if (trim_threshold >= -1) {
         mallopt(M_TRIM_THRESHOLD, trim_threshold);
@@ -7831,7 +7836,7 @@ config_set_malloc_mmap_threshold(const char *attrname, char *value, char *errorb
         return LDAP_OPERATIONS_ERROR;
     }
 
-    __atomic_store_4(&(slapdFrontendConfig->malloc_mmap_threshold), mmap_threshold, __ATOMIC_RELEASE);
+    slapi_atomic_store(&(slapdFrontendConfig->malloc_mmap_threshold), &mmap_threshold, __ATOMIC_RELEASE, ATOMIC_INT);
 
     if ((mmap_threshold >= 0) && (mmap_threshold <= max)) {
         mallopt(M_MMAP_THRESHOLD, mmap_threshold);
diff --git a/ldap/servers/slapd/log.c b/ldap/servers/slapd/log.c
index 41b5c99..4d44c87 100644
--- a/ldap/servers/slapd/log.c
+++ b/ldap/servers/slapd/log.c
@@ -4942,12 +4942,13 @@ static LogBufferInfo *
 log_create_buffer(size_t sz)
 {
     LogBufferInfo *lbi;
+    uint64_t init_val = 0;
 
     lbi = (LogBufferInfo *)slapi_ch_malloc(sizeof(LogBufferInfo));
     lbi->top = (char *)slapi_ch_malloc(sz);
     lbi->current = lbi->top;
     lbi->maxsize = sz;
-    __atomic_store_8(&(lbi->refcount), 0, __ATOMIC_RELEASE);
+    slapi_atomic_store(&(lbi->refcount), &init_val, __ATOMIC_RELEASE, ATOMIC_LONG);
     return lbi;
 }
 
@@ -5009,7 +5010,7 @@ log_append_buffer2(time_t tnl, LogBufferInfo *lbi, char *msg1, size_t size1, cha
     insert_point = lbi->current;
     lbi->current += size;
     /* Increment the copy refcount */
-    __atomic_add_fetch_8(&(lbi->refcount), 1, __ATOMIC_RELEASE);
+    slapi_atomic_incr(&(lbi->refcount), __ATOMIC_RELEASE, ATOMIC_LONG);
     PR_Unlock(lbi->lock);
 
     /* Now we can copy without holding the lock */
@@ -5017,7 +5018,7 @@ log_append_buffer2(time_t tnl, LogBufferInfo *lbi, char *msg1, size_t size1, cha
     memcpy(insert_point + size1, msg2, size2);
 
     /* Decrement the copy refcount */
-    __atomic_sub_fetch_8(&(lbi->refcount), 1, __ATOMIC_RELEASE);
+    slapi_atomic_decr(&(lbi->refcount), __ATOMIC_RELEASE, ATOMIC_LONG);
 
     /* If we are asked to sync to disk immediately, do so */
     if (!slapdFrontendConfig->accesslogbuffering) {
@@ -5037,7 +5038,7 @@ log_flush_buffer(LogBufferInfo *lbi, int type, int sync_now)
     if (type == SLAPD_ACCESS_LOG) {
 
         /* It is only safe to flush once any other threads which are copying are finished */
-        while (__atomic_load_8(&(lbi->refcount), __ATOMIC_ACQUIRE) > 0) {
+        while (slapi_atomic_load(&(lbi->refcount), __ATOMIC_ACQUIRE, ATOMIC_LONG) > 0) {
             /* It's ok to sleep for a while because we only flush every second or so */
             DS_Sleep(PR_MillisecondsToInterval(1));
         }
diff --git a/ldap/servers/slapd/mapping_tree.c b/ldap/servers/slapd/mapping_tree.c
index 651d70e..6621ceb 100644
--- a/ldap/servers/slapd/mapping_tree.c
+++ b/ldap/servers/slapd/mapping_tree.c
@@ -1647,7 +1647,7 @@ mapping_tree_init()
 
     /* we call this function from a single thread, so it should be ok */
 
-    if (__atomic_load_4(&mapping_tree_freed, __ATOMIC_RELAXED)) {
+    if (slapi_atomic_load(&mapping_tree_freed, __ATOMIC_RELAXED, ATOMIC_INT)) {
         /* shutdown has been detected */
         return 0;
     }
@@ -1759,6 +1759,8 @@ mtn_free_node(mapping_tree_node **node)
 void
 mapping_tree_free()
 {
+    int init_val = 1;
+
     /* unregister dse callbacks */
     slapi_config_remove_callback(SLAPI_OPERATION_MODIFY, DSE_FLAG_PREOP, MAPPING_TREE_BASE_DN, LDAP_SCOPE_BASE, "(objectclass=*)", mapping_tree_entry_modify_callback);
     slapi_config_remove_callback(SLAPI_OPERATION_ADD, DSE_FLAG_PREOP, MAPPING_TREE_BASE_DN, LDAP_SCOPE_BASE, "(objectclass=*)", mapping_tree_entry_add_callback);
@@ -1771,7 +1773,7 @@ mapping_tree_free()
     slapi_unregister_backend_state_change_all();
     /* recursively free tree nodes */
     mtn_free_node(&mapping_tree_root);
-    __atomic_store_4(&mapping_tree_freed, 1, __ATOMIC_RELAXED);
+    slapi_atomic_store(&mapping_tree_freed, &init_val, __ATOMIC_RELAXED, ATOMIC_INT);
 }
 
 /* This function returns the first node to parse when a search is done
@@ -2022,7 +2024,7 @@ slapi_dn_write_needs_referral(Slapi_DN *target_sdn, Slapi_Entry **referral)
     mapping_tree_node *target_node = NULL;
     int ret = 0;
 
-    if (__atomic_load_4(&mapping_tree_freed, __ATOMIC_RELAXED)) {
+    if (slapi_atomic_load(&mapping_tree_freed, __ATOMIC_RELAXED, ATOMIC_INT)) {
         /* shutdown detected */
         goto done;
     }
@@ -2093,7 +2095,7 @@ slapi_mapping_tree_select(Slapi_PBlock *pb, Slapi_Backend **be, Slapi_Entry **re
     int fixup = 0;
 
 
-    if (__atomic_load_4(&mapping_tree_freed, __ATOMIC_RELAXED)) {
+    if (slapi_atomic_load(&mapping_tree_freed, __ATOMIC_RELAXED, ATOMIC_INT)) {
         /* shutdown detected */
         return LDAP_OPERATIONS_ERROR;
     }
@@ -2198,7 +2200,7 @@ slapi_mapping_tree_select_all(Slapi_PBlock *pb, Slapi_Backend **be_list, Slapi_E
     int flag_partial_result = 0;
     int op_type;
 
-    if (__atomic_load_4(&mapping_tree_freed, __ATOMIC_RELAXED)) {
+    if (slapi_atomic_load(&mapping_tree_freed, __ATOMIC_RELAXED, ATOMIC_INT)) {
         return LDAP_OPERATIONS_ERROR;
     }
 
@@ -2358,7 +2360,7 @@ slapi_mapping_tree_select_and_check(Slapi_PBlock *pb, char *newdn, Slapi_Backend
     int ret;
     int need_unlock = 0;
 
-    if (__atomic_load_4(&mapping_tree_freed, __ATOMIC_RELAXED)) {
+    if (slapi_atomic_load(&mapping_tree_freed, __ATOMIC_RELAXED, ATOMIC_INT)) {
         return LDAP_OPERATIONS_ERROR;
     }
 
@@ -2524,7 +2526,7 @@ mtn_get_be(mapping_tree_node *target_node, Slapi_PBlock *pb, Slapi_Backend **be,
     int flag_stop = 0;
     struct slapi_componentid *cid = NULL;
 
-    if (__atomic_load_4(&mapping_tree_freed, __ATOMIC_RELAXED)) {
+    if (slapi_atomic_load(&mapping_tree_freed, __ATOMIC_RELAXED, ATOMIC_INT)) {
         /* shut down detected */
         return LDAP_OPERATIONS_ERROR;
     }
@@ -2712,7 +2714,7 @@ best_matching_child(mapping_tree_node *parent,
     mapping_tree_node *highest_match_node = NULL;
     mapping_tree_node *current;
 
-    if (__atomic_load_4(&mapping_tree_freed, __ATOMIC_RELAXED)) {
+    if (slapi_atomic_load(&mapping_tree_freed, __ATOMIC_RELAXED, ATOMIC_INT)) {
         /* shutdown detected */
         return NULL;
     }
@@ -2739,7 +2741,7 @@ mtn_get_mapping_tree_node_by_entry(mapping_tree_node *node, const Slapi_DN *dn)
 {
     mapping_tree_node *found_node = NULL;
 
-    if (__atomic_load_4(&mapping_tree_freed, __ATOMIC_RELAXED)) {
+    if (slapi_atomic_load(&mapping_tree_freed, __ATOMIC_RELAXED, ATOMIC_INT)) {
         /* shutdown detected */
         return NULL;
     }
@@ -2782,7 +2784,7 @@ slapi_get_mapping_tree_node_by_dn(const Slapi_DN *dn)
     mapping_tree_node *current_best_match = mapping_tree_root;
     mapping_tree_node *next_best_match = mapping_tree_root;
 
-    if (__atomic_load_4(&mapping_tree_freed, __ATOMIC_RELAXED)) {
+    if (slapi_atomic_load(&mapping_tree_freed, __ATOMIC_RELAXED, ATOMIC_INT)) {
         /* shutdown detected */
         return NULL;
     }
@@ -2816,7 +2818,7 @@ get_mapping_tree_node_by_name(mapping_tree_node *node, char *be_name)
     int i;
     mapping_tree_node *found_node = NULL;
 
-    if (__atomic_load_4(&mapping_tree_freed, __ATOMIC_RELAXED)) {
+    if (slapi_atomic_load(&mapping_tree_freed, __ATOMIC_RELAXED, ATOMIC_INT)) {
         /* shutdown detected */
         return NULL;
     }
@@ -2863,7 +2865,7 @@ slapi_get_mapping_tree_node_configdn(const Slapi_DN *root)
 {
     char *dn = NULL;
 
-    if (__atomic_load_4(&mapping_tree_freed, __ATOMIC_RELAXED)) {
+    if (slapi_atomic_load(&mapping_tree_freed, __ATOMIC_RELAXED, ATOMIC_INT)) {
         /* shutdown detected */
         return NULL;
     }
@@ -2890,7 +2892,7 @@ slapi_get_mapping_tree_node_configsdn(const Slapi_DN *root)
     char *dn = NULL;
     Slapi_DN *sdn = NULL;
 
-    if (__atomic_load_4(&mapping_tree_freed, __ATOMIC_RELAXED)) {
+    if (slapi_atomic_load(&mapping_tree_freed, __ATOMIC_RELAXED, ATOMIC_INT)) {
         /* shutdown detected */
         return NULL;
     }
diff --git a/ldap/servers/slapd/object.c b/ldap/servers/slapd/object.c
index 84845d3..6a1a9a5 100644
--- a/ldap/servers/slapd/object.c
+++ b/ldap/servers/slapd/object.c
@@ -43,10 +43,12 @@ Object *
 object_new(void *user_data, FNFree destructor)
 {
     Object *o;
+    uint64_t init_val = 1;
+
     o = (object *)slapi_ch_malloc(sizeof(object));
     o->destructor = destructor;
     o->data = user_data;
-    __atomic_store_8(&(o->refcnt), 1, __ATOMIC_RELEASE);
+    slapi_atomic_store(&(o->refcnt), &init_val, __ATOMIC_RELEASE, ATOMIC_LONG);
     return o;
 }
 
@@ -60,7 +62,7 @@ void
 object_acquire(Object *o)
 {
     PR_ASSERT(NULL != o);
-    __atomic_add_fetch_8(&(o->refcnt), 1, __ATOMIC_RELEASE);
+    slapi_atomic_incr(&(o->refcnt), __ATOMIC_RELEASE, ATOMIC_LONG);
 }
 
 
@@ -75,7 +77,7 @@ object_release(Object *o)
     PRInt32 refcnt_after_release;
 
     PR_ASSERT(NULL != o);
-    refcnt_after_release = __atomic_sub_fetch_8(&(o->refcnt), 1, __ATOMIC_ACQ_REL);
+    refcnt_after_release = slapi_atomic_decr(&(o->refcnt), __ATOMIC_ACQ_REL, ATOMIC_LONG);
     if (refcnt_after_release == 0) {
         /* Object can be destroyed */
         if (o->destructor)
diff --git a/ldap/servers/slapd/psearch.c b/ldap/servers/slapd/psearch.c
index 0489122..70c530b 100644
--- a/ldap/servers/slapd/psearch.c
+++ b/ldap/servers/slapd/psearch.c
@@ -134,7 +134,7 @@ ps_stop_psearch_system()
     if (PS_IS_INITIALIZED()) {
         PSL_LOCK_WRITE();
         for (ps = psearch_list->pl_head; NULL != ps; ps = ps->ps_next) {
-            __atomic_add_fetch_8(&(ps->ps_complete), 1, __ATOMIC_RELEASE);
+            slapi_atomic_incr(&(ps->ps_complete), __ATOMIC_RELEASE, ATOMIC_LONG);
         }
         PSL_UNLOCK_WRITE();
         ps_wakeup_all();
@@ -285,7 +285,7 @@ ps_send_results(void *arg)
 
     PR_Lock(psearch_list->pl_cvarlock);
 
-    while ((conn_acq_flag == 0) && __atomic_load_8(&(ps->ps_complete), __ATOMIC_ACQUIRE) == 0) {
+    while ((conn_acq_flag == 0) && slapi_atomic_load(&(ps->ps_complete), __ATOMIC_ACQUIRE, ATOMIC_LONG) == 0) {
         /* Check for an abandoned operation */
         if (pb_op == NULL || slapi_op_abandoned(ps->ps_pblock)) {
             slapi_log_err(SLAPI_LOG_CONNS, "ps_send_results",
@@ -427,6 +427,7 @@ static PSearch *
 psearch_alloc(void)
 {
     PSearch *ps;
+    uint64_t init_val = 0;
 
     ps = (PSearch *)slapi_ch_calloc(1, sizeof(PSearch));
 
@@ -437,7 +438,7 @@ psearch_alloc(void)
         slapi_ch_free((void **)&ps);
         return (NULL);
     }
-    __atomic_store_8(&(ps->ps_complete), 0, __ATOMIC_RELEASE);
+    slapi_atomic_store(&(ps->ps_complete), &init_val, __ATOMIC_RELEASE, ATOMIC_LONG);
     ps->ps_eq_head = ps->ps_eq_tail = (PSEQNode *)NULL;
     ps->ps_lasttime = (time_t)0L;
     ps->ps_next = NULL;
diff --git a/ldap/servers/slapd/slapi-plugin.h b/ldap/servers/slapd/slapi-plugin.h
index 3397c63..c434add 100644
--- a/ldap/servers/slapd/slapi-plugin.h
+++ b/ldap/servers/slapd/slapi-plugin.h
@@ -8202,6 +8202,58 @@ void slapi_operation_time_initiated(Slapi_Operation *o, struct timespec *initiat
  */
 #endif
 
+/* See: https://gcc.gnu.org/ml/gcc/2016-11/txt6ZlA_JS27i.txt */
+#define ATOMIC_GENERIC  0
+#define ATOMIC_INT      4
+#define ATOMIC_LONG     8
+#define ATOMIC_INT128  16  /* Future */
+
+/**
+ * Store an integral value atomicly
+ *
+ * \param ptr - integral pointer
+ * \param val - pointer to integral value (use integral type int32_t with ATOMIC_INT, or uint64_t
+ * with ATOMIC_LONG & ATOMIC_GENERIC)
+ * \param memorder - __ATOMIC_RELAXED, __ATOMIC_CONSUME, __ATOMIC_ACQUIRE,
+ * __ATOMIC_RELEASE, __ATOMIC_ACQ_REL, __ATOMIC_SEQ_CST
+ * \param type - "ptr" type: ATOMIC_GENERIC, ATOMIC_INT, or ATOMIC_LONG
+ */
+void slapi_atomic_store(void *ptr, void *val, int memorder, int type);
+
+/**
+ * Get an integral value atomicly
+ *
+ * \param ptr - integral pointer
+ * \param memorder - __ATOMIC_RELAXED, __ATOMIC_CONSUME, __ATOMIC_ACQUIRE,
+ * __ATOMIC_RELEASE, __ATOMIC_ACQ_REL, __ATOMIC_SEQ_CST
+ * \param type - "ptr" type: ATOMIC_GENERIC, ATOMIC_INT, or ATOMIC_LONG
+ * \return -
+ */
+uint64_t slapi_atomic_load(void *ptr, int memorder, int type);
+
+/**
+ * Increment integral atomicly
+ *
+ * \param ptr - pointer to integral to increment
+ * \param memorder - __ATOMIC_RELAXED, __ATOMIC_CONSUME, __ATOMIC_ACQUIRE,
+ * __ATOMIC_RELEASE, __ATOMIC_ACQ_REL, __ATOMIC_SEQ_CST
+ * \param type - "ptr" type: ATOMIC_GENERIC, ATOMIC_INT, or ATOMIC_LONG
+ * \return - new value of ptr
+ */
+uint64_t slapi_atomic_incr(void *ptr, int memorder, int type);
+
+/**
+ * Decrement integral atomicly
+ *
+ * \param ptr - pointer to integral to decrement
+ * \param memorder - __ATOMIC_RELAXED, __ATOMIC_CONSUME, __ATOMIC_ACQUIRE,
+ * __ATOMIC_RELEASE, __ATOMIC_ACQ_REL, __ATOMIC_SEQ_CST
+ * \param type - "ptr" type: ATOMIC_GENERIC, ATOMIC_INT, or ATOMIC_LONG
+ * \return - new value of ptr
+ */
+uint64_t slapi_atomic_decr(void *ptr, int memorder, int type);
+
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/ldap/servers/slapd/slapi_counter.c b/ldap/servers/slapd/slapi_counter.c
index ba0091f..9e705b3 100644
--- a/ldap/servers/slapd/slapi_counter.c
+++ b/ldap/servers/slapd/slapi_counter.c
@@ -283,3 +283,103 @@ slapi_counter_get_value(Slapi_Counter *counter)
 
     return value;
 }
+
+
+/*
+ *
+ * Atomic functions
+ *
+ * ptr - a pointer to an integral type variable: int, uint32_t, uint64_t, etc
+ *
+ * memorder - __ATOMIC_RELAXED, __ATOMIC_CONSUME, __ATOMIC_ACQUIRE,
+ * __ATOMIC_RELEASE, __ATOMIC_ACQ_REL, or __ATOMIC_SEQ_CST
+ *
+ *     See: https://gcc.gnu.org/onlinedocs/gcc-4.9.2/gcc/_005f_005fatomic-Builtins.html
+ *
+ * type_size - ATOMIC_GENERIC, ATOMIC_INT, or ATOMIC_LONG, see slapi-plugin.h for more info
+ *
+ * Future:
+ *    If we need to support ATOMIC_INT128 (not available on 32bit systems):
+ *         __atomic_store_16((uint64_t *)&ptr, val, memorder);
+ *         __atomic_load_16((uint64_t *)&ptr, memorder);
+ *         __atomic_add_fetch_16((uint64_t *)&ptr, 1, memorder);
+ *         __atomic_sub_fetch_16((uint64_t *)&ptr, 1, memorder);
+ */
+
+/*
+ * "val" must be either int32_t or uint64_t
+ */
+void
+slapi_atomic_store(void *ptr, void *val, int memorder, int type_size)
+{
+#ifdef ATOMIC_64BIT_OPERATIONS
+    if (type_size == ATOMIC_INT) {
+        __atomic_store_4((int32_t *)ptr, *(int32_t *)val, memorder);
+    } else if (type_size == ATOMIC_LONG) {
+        __atomic_store_8((uint64_t *)ptr, *(uint64_t *)val, memorder);
+    } else {
+        /* ATOMIC_GENERIC or unknown size */
+        __atomic_store((uint64_t *)&ptr, (uint64_t *)val, memorder);
+    }
+#else
+    PRInt32 *pr_ptr = (PRInt32 *)ptr;
+    PR_AtomicSet(pr_ptr, *(PRInt32 *)val);
+#endif
+}
+
+uint64_t
+slapi_atomic_load(void *ptr, int memorder, int type_size)
+{
+#ifdef ATOMIC_64BIT_OPERATIONS
+    uint64_t ret;
+
+    if (type_size == ATOMIC_INT) {
+        return __atomic_load_4((int32_t *)ptr, memorder);
+    } else if (type_size == ATOMIC_LONG) {
+        return __atomic_load_8((uint64_t *)ptr, memorder);
+    } else {
+        /* ATOMIC_GENERIC or unknown size */
+        __atomic_load((uint64_t *)ptr, &ret, memorder);
+        return ret;
+    }
+#else
+    PRInt32 *pr_ptr = (PRInt32 *)ptr;
+    return PR_AtomicAdd(pr_ptr, 0);
+#endif
+}
+
+uint64_t
+slapi_atomic_incr(void *ptr, int memorder, int type_size)
+{
+#ifdef ATOMIC_64BIT_OPERATIONS
+    if (type_size == ATOMIC_INT) {
+        return __atomic_add_fetch_4((int32_t *)ptr, 1, memorder);
+    } else if (type_size == ATOMIC_LONG) {
+        return __atomic_add_fetch_8((uint64_t *)ptr, 1, memorder);
+    } else {
+        /* ATOMIC_GENERIC or unknown size */
+        return __atomic_add_fetch((uint64_t *)ptr, 1, memorder);
+    }
+#else
+    PRInt32 *pr_ptr = (PRInt32 *)ptr;
+    return PR_AtomicIncrement(pr_ptr);
+#endif
+}
+
+uint64_t
+slapi_atomic_decr(void *ptr, int memorder, int type_size)
+{
+#ifdef ATOMIC_64BIT_OPERATIONS
+    if (type_size == ATOMIC_INT) {
+        return __atomic_sub_fetch_4((int32_t *)ptr, 1, memorder);
+    } else if (type_size == ATOMIC_LONG) {
+        return __atomic_sub_fetch_8((uint64_t *)ptr, 1, memorder);
+    } else {
+        /* ATOMIC_GENERIC or unknown size */
+        return __atomic_sub_fetch((uint64_t *)ptr, 1, memorder);
+    }
+#else
+    PRInt32 *pr_ptr = (PRInt32 *)ptr;
+    return PR_AtomicDecrement(pr_ptr);
+#endif
+}
diff --git a/ldap/servers/slapd/thread_data.c b/ldap/servers/slapd/thread_data.c
index 9964832..d473710 100644
--- a/ldap/servers/slapd/thread_data.c
+++ b/ldap/servers/slapd/thread_data.c
@@ -9,7 +9,7 @@
 /*
  *   Thread Local Storage Functions
  */
-#include <slapi-plugin.h>
+#include "slap.h"
 #include <prthread.h>
 
 void td_dn_destructor(void *priv);
diff --git a/src/nunc-stans/ns/ns_thrpool.c b/src/nunc-stans/ns/ns_thrpool.c
index 7921cbc..2ad0bd7 100644
--- a/src/nunc-stans/ns/ns_thrpool.c
+++ b/src/nunc-stans/ns/ns_thrpool.c
@@ -169,7 +169,11 @@ int32_t
 ns_thrpool_is_shutdown(struct ns_thrpool_t *tp)
 {
     int32_t result = 0;
+#ifdef ATOMIC_64BIT_OPERATIONS
     __atomic_load(&(tp->shutdown), &result, __ATOMIC_ACQUIRE);
+#else
+    result = PR_AtomicAdd(&(tp->shutdown), 0);
+#endif
     return result;
 }
 
@@ -177,7 +181,11 @@ int32_t
 ns_thrpool_is_event_shutdown(struct ns_thrpool_t *tp)
 {
     int32_t result = 0;
+#ifdef ATOMIC_64BIT_OPERATIONS
     __atomic_load(&(tp->shutdown_event_loop), &result, __ATOMIC_ACQUIRE);
+#else
+    result = PR_AtomicAdd(&(tp->shutdown_event_loop), 0);
+#endif
     return result;
 }
 
@@ -1442,8 +1450,11 @@ ns_thrpool_destroy(struct ns_thrpool_t *tp)
 #endif
     if (tp) {
         /* Set the flag to shutdown the event loop. */
+#ifdef ATOMIC_64BIT_OPERATIONS
         __atomic_add_fetch(&(tp->shutdown_event_loop), 1, __ATOMIC_RELEASE);
-
+#else
+        PR_AtomicIncrement(&(tp->shutdown_event_loop));
+#endif
         /* Finish the event queue wakeup job.  This has the
          * side effect of waking up the event loop thread, which
          * will cause it to exit since we set the event loop
@@ -1532,7 +1543,11 @@ ns_thrpool_shutdown(struct ns_thrpool_t *tp)
 
     /* Set the shutdown flag.  This will cause the worker
      * threads to exit after they finish all remaining work. */
+#ifdef ATOMIC_64BIT_OPERATIONS
     __atomic_add_fetch(&(tp->shutdown), 1, __ATOMIC_RELEASE);
+#else
+    PR_AtomicIncrement(&(tp->shutdown));
+#endif
 
     /* Send worker shutdown jobs into the queues. This allows
      * currently queued jobs to complete.
diff --git a/src/nunc-stans/test/test_nuncstans_stress_core.c b/src/nunc-stans/test/test_nuncstans_stress_core.c
index a678800..2fc4ef4 100644
--- a/src/nunc-stans/test/test_nuncstans_stress_core.c
+++ b/src/nunc-stans/test/test_nuncstans_stress_core.c
@@ -128,7 +128,11 @@ server_conn_write(struct ns_job_t *job)
     assert(connctx != NULL);
     if (NS_JOB_IS_TIMER(ns_job_get_output_type(job))) {
         do_logging(LOG_ERR, "conn_write: job [%p] timeout\n", job);
+#ifdef ATOMIC_64BIT_OPERATIONS
         __atomic_add_fetch(&server_fail_count, 1, __ATOMIC_SEQ_CST);
+#else
+        PR_AtomicIncrement(&server_fail_count);
+#endif
         conn_ctx_free(connctx);
         assert_int_equal(ns_job_done(job), 0);
         return;
@@ -173,7 +177,11 @@ server_conn_read(struct ns_job_t *job)
     if (NS_JOB_IS_TIMER(ns_job_get_output_type(job))) {
         /* The event that triggered this call back is because we timed out waiting for IO */
         do_logging(LOG_ERR, "conn_read: job [%p] timed out\n", job);
+#ifdef ATOMIC_64BIT_OPERATIONS
         __atomic_add_fetch(&server_fail_count, 1, __ATOMIC_SEQ_CST);
+#else
+        PR_AtomicIncrement(&server_fail_count);
+#endif
         conn_ctx_free(connctx);
         assert_int_equal(ns_job_done(job), 0);
         return;
@@ -204,7 +212,11 @@ server_conn_read(struct ns_job_t *job)
             return;
         } else {
             do_logging(LOG_ERR, "conn_read: read error for job [%p] %d: %s\n", job, PR_GetError(), PR_ErrorToString(PR_GetError(), PR_LANGUAGE_I_DEFAULT));
+#ifdef ATOMIC_64BIT_OPERATIONS
             __atomic_add_fetch(&server_fail_count, 1, __ATOMIC_SEQ_CST);
+#else
+            PR_AtomicIncrement(&server_fail_count);
+#endif
             conn_ctx_free(connctx);
             assert_int_equal(ns_job_done(job), 0);
             return;
@@ -214,7 +226,11 @@ server_conn_read(struct ns_job_t *job)
         /* Didn't read anything */
         do_logging(LOG_DEBUG, "conn_read: job [%p] closed\n", job);
         /* Increment the success */
+#ifdef ATOMIC_64BIT_OPERATIONS
         __atomic_add_fetch(&server_success_count, 1, __ATOMIC_SEQ_CST);
+#else
+        PR_AtomicIncrement(&server_success_count);
+#endif
         conn_ctx_free(connctx);
         assert_int_equal(ns_job_done(job), 0);
         return;
@@ -314,26 +330,41 @@ client_response_cb(struct ns_job_t *job)
     if (len < 0) {
         /* PRErrorCode prerr = PR_GetError(); */
         do_logging(LOG_ERR, "FAIL: connection error, no data \n");
+#ifdef ATOMIC_64BIT_OPERATIONS
         __atomic_add_fetch(&client_fail_count, 1, __ATOMIC_SEQ_CST);
+#else
+        PR_AtomicIncrement(&client_fail_count);
+#endif
         goto done;
     } else if (len == 0) {
         do_logging(LOG_ERR, "FAIL: connection closed, no data \n");
+#ifdef ATOMIC_64BIT_OPERATIONS
         __atomic_add_fetch(&client_fail_count, 1, __ATOMIC_SEQ_CST);
+#else
+        PR_AtomicIncrement(&client_fail_count);
+#endif
         goto done;
     } else {
         /* Be paranoid, force last byte null */
         buffer[buflen - 1] = '\0';
         if (strncmp("this is a test!\n", buffer, strlen("this is a test!\n")) != 0) {
             do_logging(LOG_ERR, "FAIL: connection incorrect response, no data \n");
+#ifdef ATOMIC_64BIT_OPERATIONS
             __atomic_add_fetch(&client_fail_count, 1, __ATOMIC_SEQ_CST);
+#else
+            PR_AtomicIncrement(&client_fail_count);
+#endif
             goto done;
         }
     }
 
     struct timespec ts;
     clock_gettime(CLOCK_MONOTONIC, &ts);
-
+#ifdef ATOMIC_64BIT_OPERATIONS
     __atomic_add_fetch(&client_success_count, 1, __ATOMIC_SEQ_CST);
+#else
+    PR_AtomicIncrement(&client_success_count);
+#endif
     do_logging(LOG_ERR, "PASS: %ld.%ld %d\n", ts.tv_sec, ts.tv_nsec, client_success_count);
 
 done:
@@ -354,7 +385,11 @@ client_initiate_connection_cb(struct ns_job_t *job)
         char *err = NULL;
         PR_GetErrorText(err);
         do_logging(LOG_ERR, "FAIL: Socket failed, %d -> %s\n", PR_GetError(), err);
+#ifdef ATOMIC_64BIT_OPERATIONS
         __atomic_add_fetch(&client_fail_count, 1, __ATOMIC_SEQ_CST);
+#else
+        PR_AtomicIncrement(&client_fail_count);
+#endif
         goto done;
     }
 
@@ -368,8 +403,11 @@ client_initiate_connection_cb(struct ns_job_t *job)
         PR_GetErrorText(err);
         do_logging(LOG_ERR, "FAIL: cannot connect, timeout %d -> %s \n", PR_GetError(), err);
         /* Atomic increment fail */
+#ifdef ATOMIC_64BIT_OPERATIONS
         __atomic_add_fetch(&client_timeout_count, 1, __ATOMIC_SEQ_CST);
-
+#else
+        PR_AtomicIncrement(&client_timeout_count);
+#endif
         if (sock != NULL) {
             PR_Close(sock);
         }
-- 
2.9.5

