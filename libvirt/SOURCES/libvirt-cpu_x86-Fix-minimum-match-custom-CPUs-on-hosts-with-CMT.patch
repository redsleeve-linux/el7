From 1433f648ba50ee55b5c4ee2170fbe9433795d7c8 Mon Sep 17 00:00:00 2001
Message-Id: <1433f648ba50ee55b5c4ee2170fbe9433795d7c8@dist-git>
From: Jiri Denemark <jdenemar@redhat.com>
Date: Wed, 7 Sep 2016 15:16:57 +0200
Subject: [PATCH] cpu_x86: Fix minimum match custom CPUs on hosts with CMT

Since the introduction of CMT features (commit v1.3.5-461-gf294b83)
starting a domain with custom CPU and match='minimum' on a host which
supports CMT fails because QEMU complains about unknown 'cmt' feature.

"cpu_x86: Fix host-model CPUs on hosts with CMT" commit fixed similar
issue for host-model CPUs.

This patch is a RHEL-only hack because upstream fixes this by unifying
the code for these two types of CPUs, but the upstream solution is
invasive and cannot be easily backported.

https://bugzilla.redhat.com/show_bug.cgi?id=1365500

Signed-off-by: Jiri Denemark <jdenemar@redhat.com>
---
 src/cpu/cpu_x86.c | 18 +++++++++++++-----
 1 file changed, 13 insertions(+), 5 deletions(-)

diff --git a/src/cpu/cpu_x86.c b/src/cpu/cpu_x86.c
index 670b02e..d7c58cf 100644
--- a/src/cpu/cpu_x86.c
+++ b/src/cpu/cpu_x86.c
@@ -456,7 +456,8 @@ static int
 x86DataToCPUFeatures(virCPUDefPtr cpu,
                      int policy,
                      virCPUx86Data *data,
-                     virCPUx86MapPtr map)
+                     virCPUx86MapPtr map,
+                     bool filter)
 {
     size_t i;
 
@@ -464,6 +465,13 @@ x86DataToCPUFeatures(virCPUDefPtr cpu,
         virCPUx86FeaturePtr feature = map->features[i];
         if (x86DataIsSubset(data, &feature->data)) {
             x86DataSubtract(data, &feature->data);
+
+            if (filter &&
+                (STREQ(feature->name, "cmt") ||
+                 STREQ(feature->name, "mbm_total") ||
+                 STREQ(feature->name, "mbm_local")))
+                continue;
+
             if (virCPUDefAddFeature(cpu, feature->name, policy) < 0)
                 return -1;
         }
@@ -595,8 +603,8 @@ x86DataToCPU(const virCPUx86Data *data,
     /* because feature policy is ignored for host CPU */
     cpu->type = VIR_CPU_TYPE_GUEST;
 
-    if (x86DataToCPUFeatures(cpu, VIR_CPU_FEATURE_REQUIRE, &copy, map) ||
-        x86DataToCPUFeatures(cpu, VIR_CPU_FEATURE_DISABLE, &modelData, map))
+    if (x86DataToCPUFeatures(cpu, VIR_CPU_FEATURE_REQUIRE, &copy, map, false) ||
+        x86DataToCPUFeatures(cpu, VIR_CPU_FEATURE_DISABLE, &modelData, map, false))
         goto error;
 
  cleanup:
@@ -1835,7 +1843,7 @@ x86Decode(virCPUDefPtr cpu,
 
         x86DataSubtract(&copy, &features);
         if (x86DataToCPUFeatures(cpuModel, VIR_CPU_FEATURE_REQUIRE,
-                                 &copy, map) < 0)
+                                 &copy, map, false) < 0)
             goto cleanup;
     }
 
@@ -2503,7 +2511,7 @@ x86UpdateCustom(virCPUDefPtr guest,
         guest->match = VIR_CPU_MATCH_EXACT;
         if (x86ModelSubtractCPU(host_model, guest, map) ||
             x86DataToCPUFeatures(guest, VIR_CPU_FEATURE_REQUIRE,
-                                 &host_model->data, map))
+                                 &host_model->data, map, true))
             goto cleanup;
     }
 
-- 
2.10.0

