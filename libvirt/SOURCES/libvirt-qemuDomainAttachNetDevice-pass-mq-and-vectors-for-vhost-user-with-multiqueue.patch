From 9e58c2baa75edb40ec0176c81c32081c10ed8967 Mon Sep 17 00:00:00 2001
Message-Id: <9e58c2baa75edb40ec0176c81c32081c10ed8967@dist-git>
From: gaohaifeng <gaohaifeng.gao@huawei.com>
Date: Thu, 15 Dec 2016 18:17:47 +0100
Subject: [PATCH] qemuDomainAttachNetDevice: pass mq and vectors for vhost-user
 with multiqueue

RHEL-7.4: https://bugzilla.redhat.com/show_bug.cgi?id=1386976
RHEL-7.3.z: https://bugzilla.redhat.com/show_bug.cgi?id=1404186

Two reasons:
1.in none hotplug, we will pass it. We can see from libvirt function
qemuBuildVhostuserCommandLine
2.qemu will use this vetcor num to init msix table. If we don't pass, qemu
will use default value, this will cause VM can only use default value
interrupts at most.

Signed-off-by: gaohaifeng <gaohaifeng.gao@huawei.com>
(cherry picked from commit f81b33b50c6cad384d32067c8e28f404f54a530d)
Signed-off-by: Michal Privoznik <mprivozn@redhat.com>
---
 src/qemu/qemu_hotplug.c | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/src/qemu/qemu_hotplug.c b/src/qemu/qemu_hotplug.c
index 7e4a653e6..62e275e94 100644
--- a/src/qemu/qemu_hotplug.c
+++ b/src/qemu/qemu_hotplug.c
@@ -892,6 +892,7 @@ qemuDomainAttachNetDevice(virQEMUDriverPtr driver,
     char **vhostfdName = NULL;
     int *vhostfd = NULL;
     size_t vhostfdSize = 0;
+    size_t queueSize = 0;
     char *nicstr = NULL;
     char *netstr = NULL;
     virNetDevVPortProfilePtr vport = NULL;
@@ -955,6 +956,7 @@ qemuDomainAttachNetDevice(virQEMUDriverPtr driver,
         tapfdSize = vhostfdSize = net->driver.virtio.queues;
         if (!tapfdSize)
             tapfdSize = vhostfdSize = 1;
+        queueSize = tapfdSize;
         if (VIR_ALLOC_N(tapfd, tapfdSize) < 0)
             goto cleanup;
         memset(tapfd, -1, sizeof(*tapfd) * tapfdSize);
@@ -974,6 +976,7 @@ qemuDomainAttachNetDevice(virQEMUDriverPtr driver,
         tapfdSize = vhostfdSize = net->driver.virtio.queues;
         if (!tapfdSize)
             tapfdSize = vhostfdSize = 1;
+        queueSize = tapfdSize;
         if (VIR_ALLOC_N(tapfd, tapfdSize) < 0)
             goto cleanup;
         memset(tapfd, -1, sizeof(*tapfd) * tapfdSize);
@@ -994,6 +997,7 @@ qemuDomainAttachNetDevice(virQEMUDriverPtr driver,
         tapfdSize = vhostfdSize = net->driver.virtio.queues;
         if (!tapfdSize)
             tapfdSize = vhostfdSize = 1;
+        queueSize = tapfdSize;
         if (VIR_ALLOC_N(tapfd, tapfdSize) < 0)
             goto cleanup;
         memset(tapfd, -1, sizeof(*tapfd) * tapfdSize);
@@ -1024,6 +1028,9 @@ qemuDomainAttachNetDevice(virQEMUDriverPtr driver,
         break;
 
     case VIR_DOMAIN_NET_TYPE_VHOSTUSER:
+        queueSize = net->driver.virtio.queues;
+        if (!queueSize)
+            queueSize = 1;
         if (!qemuDomainSupportsNetdev(vm->def, priv->qemuCaps, net)) {
             virReportError(VIR_ERR_INTERNAL_ERROR,
                            "%s", _("Netdev support unavailable"));
@@ -1166,7 +1173,7 @@ qemuDomainAttachNetDevice(virQEMUDriverPtr driver,
         VIR_FORCE_CLOSE(vhostfd[i]);
 
     if (!(nicstr = qemuBuildNicDevStr(vm->def, net, vlan, 0,
-                                      vhostfdSize, priv->qemuCaps)))
+                                      queueSize, priv->qemuCaps)))
         goto try_remove;
 
     qemuDomainObjEnterMonitor(driver, vm);
-- 
2.11.0

