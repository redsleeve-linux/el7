From e88d64a75a55dcd0173ba35b6f100d2ec5fcf312 Mon Sep 17 00:00:00 2001
Message-Id: <e88d64a75a55dcd0173ba35b6f100d2ec5fcf312@dist-git>
From: Peter Krempa <pkrempa@redhat.com>
Date: Wed, 7 Jun 2017 13:31:21 +0200
Subject: [PATCH] qemu: Conditionally allow block-copy for persistent domains

Allow starting the block-copy job for a persistent domain if a user
declares by using a flag that the job will not be recovered if the VM is
switched off while the job is active.

This allows to use the block-copy job with persistent VMs under the same
conditions as would apply to transient domains.

(cherry picked from commit b7e534c651bfa28c65f7b11661b478613c96598c)

Resolves: https://bugzilla.redhat.com/show_bug.cgi?id=1459113

Signed-off-by: Jiri Denemark <jdenemar@redhat.com>
---
 include/libvirt/libvirt-domain.h | 3 +++
 src/libvirt-domain.c             | 4 ++++
 src/qemu/qemu_driver.c           | 9 ++++++---
 3 files changed, 13 insertions(+), 3 deletions(-)

diff --git a/include/libvirt/libvirt-domain.h b/include/libvirt/libvirt-domain.h
index 720db32f76..45f939a8cc 100644
--- a/include/libvirt/libvirt-domain.h
+++ b/include/libvirt/libvirt-domain.h
@@ -2428,6 +2428,9 @@ typedef enum {
                                                  backing chain */
     VIR_DOMAIN_BLOCK_COPY_REUSE_EXT = 1 << 1, /* Reuse existing external
                                                  file for a copy */
+    VIR_DOMAIN_BLOCK_COPY_TRANSIENT_JOB = 1 << 2, /* Don't force usage of
+                                                     recoverable job for the
+                                                     copy operation */
 } virDomainBlockCopyFlags;
 
 /**
diff --git a/src/libvirt-domain.c b/src/libvirt-domain.c
index 4670c54e5e..0adc9e8cbe 100644
--- a/src/libvirt-domain.c
+++ b/src/libvirt-domain.c
@@ -10026,6 +10026,10 @@ virDomainBlockRebase(virDomainPtr dom, const char *disk,
  * or virDomainDetachDevice(), while a copy job is active; they may
  * also restrict a copy job to transient domains.
  *
+ * If @flags contains VIR_DOMAIN_BLOCK_COPY_TRANSIENT_JOB the job will not be
+ * recoverable if the VM is turned off while job is active. This flag will
+ * remove the restriction of copy jobs to transient domains.
+ *
  * The @disk parameter is either an unambiguous source name of the
  * block device (the <source file='...'/> sub-element, such as
  * "/path/to/image"), or the device target shorthand (the
diff --git a/src/qemu/qemu_driver.c b/src/qemu/qemu_driver.c
index a9ac06a63c..354329fe64 100644
--- a/src/qemu/qemu_driver.c
+++ b/src/qemu/qemu_driver.c
@@ -16509,7 +16509,8 @@ qemuDomainBlockCopyCommon(virDomainObjPtr vm,
 
     /* Preliminaries: find the disk we are editing, sanity checks */
     virCheckFlags(VIR_DOMAIN_BLOCK_COPY_SHALLOW |
-                  VIR_DOMAIN_BLOCK_COPY_REUSE_EXT, -1);
+                  VIR_DOMAIN_BLOCK_COPY_REUSE_EXT |
+                  VIR_DOMAIN_BLOCK_COPY_TRANSIENT_JOB, -1);
 
     priv = vm->privateData;
     cfg = virQEMUDriverGetConfig(driver);
@@ -16548,7 +16549,8 @@ qemuDomainBlockCopyCommon(virDomainObjPtr vm,
                        _("block copy is not supported with this QEMU binary"));
         goto endjob;
     }
-    if (vm->persistent) {
+    if (!(flags & VIR_DOMAIN_BLOCK_COPY_TRANSIENT_JOB) &&
+        vm->persistent) {
         /* XXX if qemu ever lets us start a new domain with mirroring
          * already active, we can relax this; but for now, the risk of
          * 'managedsave' due to libvirt-guests means we can't risk
@@ -16775,7 +16777,8 @@ qemuDomainBlockCopy(virDomainPtr dom, const char *disk, const char *destxml,
     size_t i;
 
     virCheckFlags(VIR_DOMAIN_BLOCK_COPY_SHALLOW |
-                  VIR_DOMAIN_BLOCK_COPY_REUSE_EXT, -1);
+                  VIR_DOMAIN_BLOCK_COPY_REUSE_EXT |
+                  VIR_DOMAIN_BLOCK_COPY_TRANSIENT_JOB, -1);
     if (virTypedParamsValidate(params, nparams,
                                VIR_DOMAIN_BLOCK_COPY_BANDWIDTH,
                                VIR_TYPED_PARAM_ULLONG,
-- 
2.13.1

