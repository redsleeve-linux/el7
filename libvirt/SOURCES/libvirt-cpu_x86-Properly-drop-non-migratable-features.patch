From 50244446129418acbd9efd72ebbd5c166d62dc62 Mon Sep 17 00:00:00 2001
Message-Id: <50244446129418acbd9efd72ebbd5c166d62dc62@dist-git>
From: Jiri Denemark <jdenemar@redhat.com>
Date: Tue, 28 Jun 2016 11:12:41 +0200
Subject: [PATCH] cpu_x86: Properly drop non-migratable features

By removing a non-migratable feature in a for loop we would fail to drop
every second non-migratable feature if the features array contained
several of them in a row.

Signed-off-by: Jiri Denemark <jdenemar@redhat.com>
(cherry picked from commit 1ac897a15da11d1bfca2642bce3b0beaad32bcf1)

https://bugzilla.redhat.com/show_bug.cgi?id=1365500

Signed-off-by: Jiri Denemark <jdenemar@redhat.com>
---
 src/cpu/cpu_x86.c | 14 ++++++++++----
 1 file changed, 10 insertions(+), 4 deletions(-)

diff --git a/src/cpu/cpu_x86.c b/src/cpu/cpu_x86.c
index 7bb2bb6..24ef76b 100644
--- a/src/cpu/cpu_x86.c
+++ b/src/cpu/cpu_x86.c
@@ -1816,8 +1816,11 @@ x86Decode(virCPUDefPtr cpu,
      * Note: this only works as long as no CPU model contains non-migratable
      * features directly */
     if (flags & VIR_CONNECT_BASELINE_CPU_MIGRATABLE) {
-        for (i = 0; i < cpuModel->nfeatures; i++) {
-            if (!x86FeatureIsMigratable(cpuModel->features[i].name, map)) {
+        i = 0;
+        while (i < cpuModel->nfeatures) {
+            if (x86FeatureIsMigratable(cpuModel->features[i].name, map)) {
+                i++;
+            } else {
                 VIR_FREE(cpuModel->features[i].name);
                 VIR_DELETE_ELEMENT_INPLACE(cpuModel->features, i,
                                            cpuModel->nfeatures);
@@ -2542,8 +2545,11 @@ x86UpdateHostModel(virCPUDefPtr guest,
     /* Remove non-migratable features by default
      * Note: this only works as long as no CPU model contains non-migratable
      * features directly */
-    for (i = 0; i < guest->nfeatures; i++) {
-        if (!x86FeatureIsMigratable(guest->features[i].name, map)) {
+    i = 0;
+    while (i < guest->nfeatures) {
+        if (x86FeatureIsMigratable(guest->features[i].name, map)) {
+            i++;
+        } else {
             VIR_FREE(guest->features[i].name);
             VIR_DELETE_ELEMENT_INPLACE(guest->features, i, guest->nfeatures);
         }
-- 
2.9.2

