From 9c2457dd94cf148dce04ee5fd3997003ca03a642 Mon Sep 17 00:00:00 2001
Message-Id: <9c2457dd94cf148dce04ee5fd3997003ca03a642@dist-git>
From: Jiri Denemark <jdenemar@redhat.com>
Date: Tue, 11 Jul 2017 14:16:40 +0200
Subject: [PATCH] qemu: Update host-model CPUs on reconnect

When libvirt starts a new QEMU domain, it replaces host-model CPUs with
the appropriate custom CPU definition. However, when reconnecting to a
domain started by older libvirt (< 2.3), the domain would still have a
host-model CPU in its active definition.

https://bugzilla.redhat.com/show_bug.cgi?id=1463957

Signed-off-by: Jiri Denemark <jdenemar@redhat.com>
Reviewed-by: Pavel Hrdina <phrdina@redhat.com>
(cherry picked from commit 7cf22b4879e819dee42e0a058f7ed149dc9d639a)

https://bugzilla.redhat.com/show_bug.cgi?id=1470582

Signed-off-by: Jiri Denemark <jdenemar@redhat.com>
Reviewed-by: Pavel Hrdina <phrdina@redhat.com>
---
 src/qemu/qemu_process.c | 48 ++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 48 insertions(+)

diff --git a/src/qemu/qemu_process.c b/src/qemu/qemu_process.c
index e6f56dc484..8fe9ef36d7 100644
--- a/src/qemu/qemu_process.c
+++ b/src/qemu/qemu_process.c
@@ -3718,6 +3718,30 @@ qemuProcessUpdateAndVerifyCPU(virQEMUDriverPtr driver,
 
 
 static int
+qemuProcessUpdateCPU(virQEMUDriverPtr driver,
+                     virDomainObjPtr vm,
+                     qemuDomainAsyncJob asyncJob)
+{
+    virCPUDataPtr cpu = NULL;
+    virCPUDataPtr disabled = NULL;
+    int ret = -1;
+
+    if (qemuProcessFetchGuestCPU(driver, vm, asyncJob, &cpu, &disabled) < 0)
+        goto cleanup;
+
+    if (qemuProcessUpdateLiveGuestCPU(vm, cpu, disabled) < 0)
+        goto cleanup;
+
+    ret = 0;
+
+ cleanup:
+    virCPUDataFree(cpu);
+    virCPUDataFree(disabled);
+    return ret;
+}
+
+
+static int
 qemuPrepareNVRAM(virQEMUDriverConfigPtr cfg,
                  virDomainObjPtr vm)
 {
@@ -6796,6 +6820,30 @@ qemuProcessReconnect(void *opaque)
     ignore_value(qemuSecurityCheckAllLabel(driver->securityManager,
                                            obj->def));
 
+    /* If the domain with a host-model CPU was started by an old libvirt
+     * (< 2.3) which didn't replace the CPU with a custom one, let's do it now
+     * since the rest of our code does not really expect a host-model CPU in a
+     * running domain.
+     */
+    if (virQEMUCapsGuestIsNative(caps->host.arch, obj->def->os.arch) &&
+        caps->host.cpu &&
+        obj->def->cpu &&
+        obj->def->cpu->mode == VIR_CPU_MODE_HOST_MODEL) {
+        virCPUDefPtr host;
+
+        if (!(host = virCPUCopyMigratable(caps->host.cpu->arch, caps->host.cpu)))
+            goto error;
+
+        if (virCPUUpdate(obj->def->os.arch, obj->def->cpu, host) < 0) {
+            virCPUDefFree(host);
+            goto error;
+        }
+        virCPUDefFree(host);
+
+        if (qemuProcessUpdateCPU(driver, obj, QEMU_ASYNC_JOB_NONE) < 0)
+            goto error;
+    }
+
     if (qemuDomainRefreshVcpuInfo(driver, obj, QEMU_ASYNC_JOB_NONE, true) < 0)
         goto error;
 
-- 
2.13.2

