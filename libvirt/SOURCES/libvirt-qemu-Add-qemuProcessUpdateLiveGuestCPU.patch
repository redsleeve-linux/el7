From e5840b68e6376a514c6c5de1897ac87dc57e7a58 Mon Sep 17 00:00:00 2001
Message-Id: <e5840b68e6376a514c6c5de1897ac87dc57e7a58@dist-git>
From: Jiri Denemark <jdenemar@redhat.com>
Date: Tue, 11 Jul 2017 13:51:17 +0200
Subject: [PATCH] qemu: Add qemuProcessUpdateLiveGuestCPU

Separated from qemuProcessUpdateAndVerifyCPU to handle updating of an
active guest CPU definition according to live data from QEMU.

Signed-off-by: Jiri Denemark <jdenemar@redhat.com>
Reviewed-by: Pavel Hrdina <phrdina@redhat.com>
(cherry picked from commit eef9f83b691e0713e4fc480b497b85517aba6ca4)

https://bugzilla.redhat.com/show_bug.cgi?id=1470582

Signed-off-by: Jiri Denemark <jdenemar@redhat.com>
Reviewed-by: Pavel Hrdina <phrdina@redhat.com>
---
 src/qemu/qemu_process.c | 72 ++++++++++++++++++++++++++++++-------------------
 1 file changed, 44 insertions(+), 28 deletions(-)

diff --git a/src/qemu/qemu_process.c b/src/qemu/qemu_process.c
index 1e7724e784..9df463094e 100644
--- a/src/qemu/qemu_process.c
+++ b/src/qemu/qemu_process.c
@@ -3971,17 +3971,55 @@ qemuProcessVerifyCPU(virDomainObjPtr vm,
 
 
 static int
+qemuProcessUpdateLiveGuestCPU(virDomainObjPtr vm,
+                              virCPUDataPtr enabled,
+                              virCPUDataPtr disabled)
+{
+    virDomainDefPtr def = vm->def;
+    qemuDomainObjPrivatePtr priv = vm->privateData;
+    virCPUDefPtr orig = NULL;
+    int rc;
+    int ret = -1;
+
+    if (!enabled)
+        return 0;
+
+    if (!def->cpu ||
+        (def->cpu->mode == VIR_CPU_MODE_CUSTOM &&
+         !def->cpu->model))
+        return 0;
+
+    if (!(orig = virCPUDefCopy(def->cpu)))
+        goto cleanup;
+
+    if ((rc = virCPUUpdateLive(def->os.arch, def->cpu, enabled, disabled)) < 0) {
+        goto cleanup;
+    } else if (rc == 0) {
+        /* Store the original CPU in priv if QEMU changed it and we didn't
+         * get the original CPU via migration, restore, or snapshot revert.
+         */
+        if (!priv->origCPU && !virCPUDefIsEqual(def->cpu, orig, false))
+            VIR_STEAL_PTR(priv->origCPU, orig);
+
+        def->cpu->check = VIR_CPU_CHECK_FULL;
+    }
+
+    ret = 0;
+
+ cleanup:
+    virCPUDefFree(orig);
+    return ret;
+}
+
+
+static int
 qemuProcessUpdateAndVerifyCPU(virQEMUDriverPtr driver,
                               virDomainObjPtr vm,
                               qemuDomainAsyncJob asyncJob)
 {
-    virDomainDefPtr def = vm->def;
     virCPUDataPtr cpu = NULL;
     virCPUDataPtr disabled = NULL;
-    qemuDomainObjPrivatePtr priv = vm->privateData;
-    int rc;
     int ret = -1;
-    virCPUDefPtr orig = NULL;
 
     if (qemuProcessFetchGuestCPU(driver, vm, asyncJob, &cpu, &disabled) < 0)
         goto cleanup;
@@ -3989,36 +4027,14 @@ qemuProcessUpdateAndVerifyCPU(virQEMUDriverPtr driver,
     if (qemuProcessVerifyCPU(vm, cpu) < 0)
         goto cleanup;
 
-    if (cpu) {
-        if (!def->cpu ||
-            (def->cpu->mode == VIR_CPU_MODE_CUSTOM &&
-             !def->cpu->model)) {
-            ret = 0;
-            goto cleanup;
-        }
-
-        if (!(orig = virCPUDefCopy(def->cpu)))
-            goto cleanup;
-
-        if ((rc = virCPUUpdateLive(def->os.arch, def->cpu, cpu, disabled)) < 0) {
-            goto cleanup;
-        } else if (rc == 0) {
-            /* Store the original CPU in priv if QEMU changed it and we didn't
-             * get the original CPU via migration, restore, or snapshot revert.
-             */
-            if (!priv->origCPU && !virCPUDefIsEqual(def->cpu, orig, false))
-                VIR_STEAL_PTR(priv->origCPU, orig);
-
-            def->cpu->check = VIR_CPU_CHECK_FULL;
-        }
-    }
+    if (qemuProcessUpdateLiveGuestCPU(vm, cpu, disabled) < 0)
+        goto cleanup;
 
     ret = 0;
 
  cleanup:
     virCPUDataFree(cpu);
     virCPUDataFree(disabled);
-    virCPUDefFree(orig);
     return ret;
 }
 
-- 
2.13.2

