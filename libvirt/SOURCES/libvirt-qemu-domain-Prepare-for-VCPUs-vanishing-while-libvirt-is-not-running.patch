From 285de183e4643a0173405bce5ae0703bbf61df08 Mon Sep 17 00:00:00 2001
Message-Id: <285de183e4643a0173405bce5ae0703bbf61df08@dist-git>
From: Peter Krempa <pkrempa@redhat.com>
Date: Wed, 24 Aug 2016 16:11:31 -0400
Subject: [PATCH] qemu: domain: Prepare for VCPUs vanishing while libvirt is
 not running

https://bugzilla.redhat.com/show_bug.cgi?id=1097930
https://bugzilla.redhat.com/show_bug.cgi?id=1224341

Similarly to devices the guest may allow unplug of the VCPU if libvirt
is down. To avoid problems, refresh the vcpu state on reconnect. Don't
mess with the vcpu state otherwise.

(cherry picked from commit 133be0a9e27dc28dacba4b651b8633f1a85eead9)
---
 src/qemu/qemu_domain.c  | 9 ++++++++-
 src/qemu/qemu_domain.h  | 3 ++-
 src/qemu/qemu_driver.c  | 4 ++--
 src/qemu/qemu_process.c | 7 +++++--
 4 files changed, 17 insertions(+), 6 deletions(-)

diff --git a/src/qemu/qemu_domain.c b/src/qemu/qemu_domain.c
index 259fd79..add8379 100644
--- a/src/qemu/qemu_domain.c
+++ b/src/qemu/qemu_domain.c
@@ -5714,16 +5714,20 @@ qemuDomainSupportsNewVcpuHotplug(virDomainObjPtr vm)
  * @driver: qemu driver data
  * @vm: domain object
  * @asyncJob: current asynchronous job type
+ * @state: refresh vcpu state
  *
  * Updates vCPU information private data of @vm. Due to historical reasons this
  * function returns success even if some data were not reported by qemu.
  *
+ * If @state is true, the vcpu state is refreshed as reported by the monitor.
+ *
  * Returns 0 on success and -1 on fatal error.
  */
 int
 qemuDomainRefreshVcpuInfo(virQEMUDriverPtr driver,
                           virDomainObjPtr vm,
-                          int asyncJob)
+                          int asyncJob,
+                          bool state)
 {
     virDomainVcpuDefPtr vcpu;
     qemuDomainVcpuPrivatePtr vcpupriv;
@@ -5791,6 +5795,9 @@ qemuDomainRefreshVcpuInfo(virQEMUDriverPtr driver,
         VIR_FREE(vcpupriv->alias);
         VIR_STEAL_PTR(vcpupriv->alias, info[i].alias);
         vcpupriv->enable_id = info[i].id;
+
+        if (hotplug && state)
+            vcpu->online = !!info[i].qom_path;
     }
 
     ret = 0;
diff --git a/src/qemu/qemu_domain.h b/src/qemu/qemu_domain.h
index c3ae169..76b6904 100644
--- a/src/qemu/qemu_domain.h
+++ b/src/qemu/qemu_domain.h
@@ -662,7 +662,8 @@ pid_t qemuDomainGetVcpuPid(virDomainObjPtr vm, unsigned int vcpuid);
 int qemuDomainValidateVcpuInfo(virDomainObjPtr vm);
 int qemuDomainRefreshVcpuInfo(virQEMUDriverPtr driver,
                               virDomainObjPtr vm,
-                              int asyncJob);
+                              int asyncJob,
+                              bool state);
 
 bool qemuDomainSupportsNicdev(virDomainDefPtr def,
                               virDomainNetDefPtr net);
diff --git a/src/qemu/qemu_driver.c b/src/qemu/qemu_driver.c
index 1b433f8..35ed8ec 100644
--- a/src/qemu/qemu_driver.c
+++ b/src/qemu/qemu_driver.c
@@ -4646,7 +4646,7 @@ qemuDomainHotplugAddVcpu(virQEMUDriverPtr driver,
 
     vcpuinfo->online = true;
 
-    if (qemuDomainRefreshVcpuInfo(driver, vm, QEMU_ASYNC_JOB_NONE) < 0)
+    if (qemuDomainRefreshVcpuInfo(driver, vm, QEMU_ASYNC_JOB_NONE, false) < 0)
         goto cleanup;
 
     if (qemuDomainValidateVcpuInfo(vm) < 0)
@@ -4695,7 +4695,7 @@ qemuDomainHotplugDelVcpu(virQEMUDriverPtr driver,
         goto cleanup;
     }
 
-    if (qemuDomainRefreshVcpuInfo(driver, vm, QEMU_ASYNC_JOB_NONE) < 0)
+    if (qemuDomainRefreshVcpuInfo(driver, vm, QEMU_ASYNC_JOB_NONE, false) < 0)
         goto cleanup;
 
     if (qemuDomainValidateVcpuInfo(vm) < 0) {
diff --git a/src/qemu/qemu_process.c b/src/qemu/qemu_process.c
index cdfd1e3..1726608 100644
--- a/src/qemu/qemu_process.c
+++ b/src/qemu/qemu_process.c
@@ -3353,6 +3353,9 @@ qemuProcessReconnect(void *opaque)
     ignore_value(virSecurityManagerCheckAllLabel(driver->securityManager,
                                                  obj->def));
 
+    if (qemuDomainRefreshVcpuInfo(driver, obj, QEMU_ASYNC_JOB_NONE, true) < 0)
+        goto error;
+
     if (virSecurityManagerReserveLabel(driver->securityManager, obj->def, obj->pid) < 0)
         goto error;
 
@@ -5193,7 +5196,7 @@ qemuProcessLaunch(virConnectPtr conn,
         goto cleanup;
 
     VIR_DEBUG("Refreshing VCPU info");
-    if (qemuDomainRefreshVcpuInfo(driver, vm, asyncJob) < 0)
+    if (qemuDomainRefreshVcpuInfo(driver, vm, asyncJob, false) < 0)
         goto cleanup;
 
     if (qemuDomainValidateVcpuInfo(vm) < 0)
@@ -5990,7 +5993,7 @@ int qemuProcessAttach(virConnectPtr conn ATTRIBUTE_UNUSED,
     }
 
     VIR_DEBUG("Detecting VCPU PIDs");
-    if (qemuDomainRefreshVcpuInfo(driver, vm, QEMU_ASYNC_JOB_NONE) < 0)
+    if (qemuDomainRefreshVcpuInfo(driver, vm, QEMU_ASYNC_JOB_NONE, false) < 0)
         goto error;
 
     if (qemuDomainValidateVcpuInfo(vm) < 0)
-- 
2.10.0

