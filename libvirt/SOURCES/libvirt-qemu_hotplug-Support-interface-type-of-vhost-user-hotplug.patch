From 6ad2b5b70219158aa873058b4d4b1d94c481640d Mon Sep 17 00:00:00 2001
Message-Id: <6ad2b5b70219158aa873058b4d4b1d94c481640d@dist-git>
From: Michal Privoznik <mprivozn@redhat.com>
Date: Tue, 8 Nov 2016 13:42:13 +0100
Subject: [PATCH] qemu_hotplug: Support interface type of vhost-user hotplug

RHEL-7.3: https://bugzilla.redhat.com/show_bug.cgi?id=1366108
RHEL-7.3.z: https://bugzilla.redhat.com/show_bug.cgi?id=1392032

There are couple of things that needs to be done in order to
allow vhost-user hotplug. Firstly, vhost-user requires a chardev
which is connected to vhost-user bridge and through which qemu
communicates with the bridge (no acutal guest traffic is sent
through there, just some metadata). In order to generate proper
chardev alias, we must assign device alias way sooner.

Then, because we are plugging the chardev first, we need to do
the proper undo if something fails - that is remove netdev too.
We don't want anything to be left over in case attach fails at
some point.

Signed-off-by: Michal Privoznik <mprivozn@redhat.com>
(cherry picked from commit ff89d5cbcf266e780b4ff93960969b3a6c2e9a01)
Signed-off-by: Michal Privoznik <mprivozn@redhat.com>
---
 src/qemu/qemu_hotplug.c | 71 +++++++++++++++++++++++++++++++++++++++++--------
 1 file changed, 60 insertions(+), 11 deletions(-)

diff --git a/src/qemu/qemu_hotplug.c b/src/qemu/qemu_hotplug.c
index 011152762..8acbf370b 100644
--- a/src/qemu/qemu_hotplug.c
+++ b/src/qemu/qemu_hotplug.c
@@ -902,6 +902,10 @@ qemuDomainAttachNetDevice(virQEMUDriverPtr driver,
     virNetDevBandwidthPtr actualBandwidth;
     virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);
     size_t i;
+    char *charDevAlias = NULL;
+    bool charDevPlugged = false;
+    bool netdevPlugged = false;
+    bool hostPlugged = false;
 
     /* preallocate new slot for device */
     if (VIR_REALLOC_N(vm->def->nets, vm->def->nnets + 1) < 0)
@@ -940,6 +944,9 @@ qemuDomainAttachNetDevice(virQEMUDriverPtr driver,
         return -1;
     }
 
+    if (qemuAssignDeviceNetAlias(vm->def, net, -1) < 0)
+        goto cleanup;
+
     switch (actualType) {
     case VIR_DOMAIN_NET_TYPE_BRIDGE:
     case VIR_DOMAIN_NET_TYPE_NETWORK:
@@ -1014,8 +1021,18 @@ qemuDomainAttachNetDevice(virQEMUDriverPtr driver,
         goto cleanup;
         break;
 
-    case VIR_DOMAIN_NET_TYPE_USER:
     case VIR_DOMAIN_NET_TYPE_VHOSTUSER:
+        if (!qemuDomainSupportsNetdev(vm->def, priv->qemuCaps, net)) {
+            virReportError(VIR_ERR_INTERNAL_ERROR,
+                           "%s", _("Netdev support unavailable"));
+            goto cleanup;
+        }
+
+        if (virAsprintf(&charDevAlias, "char%s", net->info.alias) < 0)
+            goto cleanup;
+        break;
+
+    case VIR_DOMAIN_NET_TYPE_USER:
     case VIR_DOMAIN_NET_TYPE_SERVER:
     case VIR_DOMAIN_NET_TYPE_CLIENT:
     case VIR_DOMAIN_NET_TYPE_MCAST:
@@ -1051,9 +1068,6 @@ qemuDomainAttachNetDevice(virQEMUDriverPtr driver,
             goto cleanup;
     }
 
-    if (qemuAssignDeviceNetAlias(vm->def, net, -1) < 0)
-        goto cleanup;
-
     if (qemuDomainMachineIsS390CCW(vm->def) &&
         virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_VIRTIO_CCW)) {
         net->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_CCW;
@@ -1111,23 +1125,36 @@ qemuDomainAttachNetDevice(virQEMUDriverPtr driver,
     }
 
     qemuDomainObjEnterMonitor(driver, vm);
+
+    if (actualType == VIR_DOMAIN_NET_TYPE_VHOSTUSER) {
+        if (qemuMonitorAttachCharDev(priv->mon, charDevAlias, net->data.vhostuser) < 0) {
+            ignore_value(qemuDomainObjExitMonitor(driver, vm));
+            virDomainAuditNet(vm, NULL, net, "attach", false);
+            goto cleanup;
+        }
+        charDevPlugged = true;
+    }
+
     if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_NETDEV)) {
         if (qemuMonitorAddNetdev(priv->mon, netstr,
                                  tapfd, tapfdName, tapfdSize,
                                  vhostfd, vhostfdName, vhostfdSize) < 0) {
             ignore_value(qemuDomainObjExitMonitor(driver, vm));
             virDomainAuditNet(vm, NULL, net, "attach", false);
-            goto cleanup;
+            goto try_remove;
         }
+        netdevPlugged = true;
     } else {
         if (qemuMonitorAddHostNetwork(priv->mon, netstr,
                                       tapfd, tapfdName, tapfdSize,
                                       vhostfd, vhostfdName, vhostfdSize) < 0) {
             ignore_value(qemuDomainObjExitMonitor(driver, vm));
             virDomainAuditNet(vm, NULL, net, "attach", false);
-            goto cleanup;
+            goto try_remove;
         }
+        hostPlugged = true;
     }
+
     if (qemuDomainObjExitMonitor(driver, vm) < 0)
         goto cleanup;
 
@@ -1230,6 +1257,7 @@ qemuDomainAttachNetDevice(virQEMUDriverPtr driver,
     }
     VIR_FREE(vhostfd);
     VIR_FREE(vhostfdName);
+    VIR_FREE(charDevAlias);
     virObjectUnref(cfg);
 
     return ret;
@@ -1244,7 +1272,11 @@ qemuDomainAttachNetDevice(virQEMUDriverPtr driver,
             if (virAsprintf(&netdev_name, "host%s", net->info.alias) < 0)
                 goto cleanup;
             qemuDomainObjEnterMonitor(driver, vm);
-            if (qemuMonitorRemoveNetdev(priv->mon, netdev_name) < 0)
+            if (charDevPlugged &&
+                qemuMonitorDetachCharDev(priv->mon, charDevAlias) < 0)
+                VIR_WARN("Failed to remove associated chardev %s", charDevAlias);
+            if (netdevPlugged &&
+                qemuMonitorRemoveNetdev(priv->mon, netdev_name) < 0)
                 VIR_WARN("Failed to remove network backend for netdev %s",
                          netdev_name);
             ignore_value(qemuDomainObjExitMonitor(driver, vm));
@@ -1257,7 +1289,8 @@ qemuDomainAttachNetDevice(virQEMUDriverPtr driver,
         if (virAsprintf(&hostnet_name, "host%s", net->info.alias) < 0)
             goto cleanup;
         qemuDomainObjEnterMonitor(driver, vm);
-        if (qemuMonitorRemoveHostNetwork(priv->mon, vlan, hostnet_name) < 0)
+        if (hostPlugged &&
+            qemuMonitorRemoveHostNetwork(priv->mon, vlan, hostnet_name) < 0)
             VIR_WARN("Failed to remove network backend for vlan %d, net %s",
                      vlan, hostnet_name);
         ignore_value(qemuDomainObjExitMonitor(driver, vm));
@@ -3357,10 +3390,12 @@ qemuDomainRemoveNetDevice(virQEMUDriverPtr driver,
     virNetDevVPortProfilePtr vport;
     virObjectEventPtr event;
     char *hostnet_name = NULL;
+    char *charDevAlias = NULL;
     size_t i;
     int ret = -1;
+    int actualType = virDomainNetGetActualType(net);
 
-    if (virDomainNetGetActualType(net) == VIR_DOMAIN_NET_TYPE_HOSTDEV) {
+    if (actualType == VIR_DOMAIN_NET_TYPE_HOSTDEV) {
         /* this function handles all hostdev and netdev cleanup */
         ret = qemuDomainRemoveHostDevice(driver, vm,
                                          virDomainNetGetActualHostdev(net));
@@ -3370,9 +3405,11 @@ qemuDomainRemoveNetDevice(virQEMUDriverPtr driver,
     VIR_DEBUG("Removing network interface %s from domain %p %s",
               net->info.alias, vm, vm->def->name);
 
-    if (virAsprintf(&hostnet_name, "host%s", net->info.alias) < 0)
+    if (virAsprintf(&hostnet_name, "host%s", net->info.alias) < 0 ||
+        virAsprintf(&charDevAlias, "char%s", net->info.alias) < 0)
         goto cleanup;
 
+
     qemuDomainObjEnterMonitor(driver, vm);
     if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_NETDEV)) {
         if (qemuMonitorRemoveNetdev(priv->mon, hostnet_name) < 0) {
@@ -3395,6 +3432,17 @@ qemuDomainRemoveNetDevice(virQEMUDriverPtr driver,
             goto cleanup;
         }
     }
+
+    if (actualType == VIR_DOMAIN_NET_TYPE_VHOSTUSER) {
+        /* vhostuser has a chardev too */
+        if (qemuMonitorDetachCharDev(priv->mon, charDevAlias) < 0) {
+            /* well, this is a messy situation. Guest visible PCI device has
+             * been removed, netdev too but chardev not. The best seems to be
+             * to just ignore the error and carry on.
+             */
+        }
+    }
+
     if (qemuDomainObjExitMonitor(driver, vm) < 0)
         goto cleanup;
 
@@ -3419,7 +3467,7 @@ qemuDomainRemoveNetDevice(virQEMUDriverPtr driver,
                                                   &net->mac));
     }
 
-    if (virDomainNetGetActualType(net) == VIR_DOMAIN_NET_TYPE_DIRECT) {
+    if (actualType == VIR_DOMAIN_NET_TYPE_DIRECT) {
         ignore_value(virNetDevMacVLanDeleteWithVPortProfile(
                          net->ifname, &net->mac,
                          virDomainNetGetActualDirectDev(net),
@@ -3445,6 +3493,7 @@ qemuDomainRemoveNetDevice(virQEMUDriverPtr driver,
 
  cleanup:
     virObjectUnref(cfg);
+    VIR_FREE(charDevAlias);
     VIR_FREE(hostnet_name);
     return ret;
 }
-- 
2.11.0

