From 48c13aa1bbd505a96af170d9efe0e0540efd5b59 Mon Sep 17 00:00:00 2001
Message-Id: <48c13aa1bbd505a96af170d9efe0e0540efd5b59@dist-git>
From: Pavel Hrdina <phrdina@redhat.com>
Date: Thu, 20 Apr 2017 09:16:21 +0200
Subject: [PATCH] qemu_domain: use correct default USB controller on ppc64

The history of USB controller for ppc64 guest is complex and goes
back to libvirt 1.3.1 where the fun started.

Prior Libvirt 1.3.1 if no model for USB controller was specified
we've simply passed "-usb" on QEMU command line.

Since Libvirt 1.3.1 there is a patch (8156493d8db) that fixes this
issue by using "-device pci-ohci,..." but it breaks migration with
older Libvirts which was agreed that's acceptable.  However this
patch didn't reflect this change in the domain XML and the model
was still missing.

Since Libvirt 2.2.0 there is a patch (f55eaccb0c5) that fixes the
issue with not setting the USB model into domain XML which we need
to know about to not break the migration and since the default
model was *pci-ohci* it was used as default in this patch as well.

This patch tries to take all the previous changes into account and
also change the default for newly defined domains that don't specify
any model for USB controller.

The VIR_DOMAIN_DEF_PARSE_ABI_UPDATE is set only if new domain is
defined or new device is added into a domain which means that in
all other cases we will use the old *pci-ohci* model instead of the
better and not broken *nec-usb-xhci* model.

Resolves: https://bugzilla.redhat.com/show_bug.cgi?id=1373184

Signed-off-by: Pavel Hrdina <phrdina@redhat.com>
(cherry picked from commit 90acbc76ece8b94cfd5e5d2ebb675f7692ce7afd)
Signed-off-by: Pavel Hrdina <phrdina@redhat.com>
---
 src/qemu/qemu_domain.c | 16 ++++++++++++----
 1 file changed, 12 insertions(+), 4 deletions(-)

diff --git a/src/qemu/qemu_domain.c b/src/qemu/qemu_domain.c
index 3150e8760..c43ff3d63 100644
--- a/src/qemu/qemu_domain.c
+++ b/src/qemu/qemu_domain.c
@@ -3110,7 +3110,8 @@ qemuDomainShmemDefPostParse(virDomainShmemDefPtr shm)
 static int
 qemuDomainControllerDefPostParse(virDomainControllerDefPtr cont,
                                  const virDomainDef *def,
-                                 virQEMUCapsPtr qemuCaps)
+                                 virQEMUCapsPtr qemuCaps,
+                                 unsigned int parseFlags)
 {
     switch ((virDomainControllerType)cont->type) {
     case VIR_DOMAIN_CONTROLLER_TYPE_SCSI:
@@ -3138,9 +3139,16 @@ qemuDomainControllerDefPostParse(virDomainControllerDefPtr cont,
                  * address is found */
                 cont->model = VIR_DOMAIN_CONTROLLER_MODEL_USB_NONE;
             } else if (ARCH_IS_PPC64(def->os.arch)) {
-                /* Default USB controller for ppc64 is pci-ohci */
-                if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_PCI_OHCI))
+                /* To not break migration we need to set default USB controller
+                 * for ppc64 to pci-ohci if we cannot change ABI of the VM.
+                 * The nec-usb-xhci controller is used as default only for
+                 * newly defined domains or devices. */
+                if ((parseFlags & VIR_DOMAIN_DEF_PARSE_ABI_UPDATE) &&
+                    virQEMUCapsGet(qemuCaps, QEMU_CAPS_NEC_USB_XHCI)) {
+                    cont->model = VIR_DOMAIN_CONTROLLER_MODEL_USB_NEC_XHCI;
+                } else if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_PCI_OHCI)) {
                     cont->model = VIR_DOMAIN_CONTROLLER_MODEL_USB_PCI_OHCI;
+                }
             } else {
                 /* Default USB controller for anything else is piix3-uhci */
                 if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_PIIX3_USB_UHCI))
@@ -3339,7 +3347,7 @@ qemuDomainDeviceDefPostParse(virDomainDeviceDefPtr dev,
 
     if (dev->type == VIR_DOMAIN_DEVICE_CONTROLLER &&
         qemuDomainControllerDefPostParse(dev->data.controller, def,
-                                         qemuCaps) < 0)
+                                         qemuCaps, parseFlags) < 0)
         goto cleanup;
 
     if (dev->type == VIR_DOMAIN_DEVICE_SHMEM &&
-- 
2.12.2

