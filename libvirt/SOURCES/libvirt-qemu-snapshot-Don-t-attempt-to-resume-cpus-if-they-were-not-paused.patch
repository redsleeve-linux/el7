From d5c66c2071bea9632a4a612ce355fca79d7d372c Mon Sep 17 00:00:00 2001
Message-Id: <d5c66c2071bea9632a4a612ce355fca79d7d372c@dist-git>
From: Peter Krempa <pkrempa@redhat.com>
Date: Tue, 20 Dec 2016 18:18:16 +0100
Subject: [PATCH] qemu: snapshot: Don't attempt to resume cpus if they were not
 paused

External disk-only snapshots with recent enough qemu don't require
libvirt to pause the VM. The logic determining when to resume cpus was
slightly flawed and attempted to resume them even if they were not
paused by the snapshot code. This normally was not a problem, but with
locking enabled the code would attempt to acquire the lock twice.

The fallout of this bug would be a error from the API, but the actual
snapshot being created. The bug was introduced with when adding support
for external snapshots with memory (checkpoints) in commit f569b87.

Resolves problems described by:
https://bugzilla.redhat.com/show_bug.cgi?id=1403691 (7.4)

(cherry picked from commit 4b951d1e38259ff5d03e9eedb65095eead8099e1)

https://bugzilla.redhat.com/show_bug.cgi?id=1406765
---
 src/qemu/qemu_driver.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/qemu/qemu_driver.c b/src/qemu/qemu_driver.c
index 1e02a7f33..2e442a987 100644
--- a/src/qemu/qemu_driver.c
+++ b/src/qemu/qemu_driver.c
@@ -14323,8 +14323,6 @@ qemuDomainSnapshotCreateActiveExternal(virConnectPtr conn,
     if (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_PMSUSPENDED) {
         pmsuspended = true;
     } else if (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_RUNNING) {
-        resume = true;
-
         /* For external checkpoints (those with memory), the guest
          * must pause (either by libvirt up front, or by qemu after
          * _LIVE converges).  For disk-only snapshots with multiple
@@ -14347,6 +14345,8 @@ qemuDomainSnapshotCreateActiveExternal(virConnectPtr conn,
                                _("guest unexpectedly quit"));
                 goto cleanup;
             }
+
+            resume = true;
         }
     }
 
-- 
2.11.0

