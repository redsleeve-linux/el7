# HG changeset patch
# User zgu
# Date 1579696811 18000
#      Wed Jan 22 07:40:11 2020 -0500
# Node ID 91ea567eeabeade6b3f8d6cf10c02ba53f700eca
# Parent  082f1d3eb1649ff776cda165ed78d65bc7361ebc
8237396: JvmtiTagMap::weak_oops_do() should not trigger barriers
Reviewed-by: stefank, rkennke

diff --git a/src/hotspot/share/prims/jvmtiTagMap.cpp b/src/hotspot/share/prims/jvmtiTagMap.cpp
--- a/src/hotspot/share/prims/jvmtiTagMap.cpp
+++ b/src/hotspot/share/prims/jvmtiTagMap.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -96,6 +96,11 @@
   inline oop object_peek()  {
     return NativeAccess<ON_PHANTOM_OOP_REF | AS_NO_KEEPALIVE>::oop_load(object_addr());
   }
+
+  inline oop object_raw() {
+    return RawAccess<>::oop_load(object_addr());
+  }
+
   inline jlong tag() const  { return _tag; }
 
   inline void set_tag(jlong tag) {
@@ -3357,7 +3362,7 @@
       JvmtiTagHashmapEntry* next = entry->next();
 
       // has object been GC'ed
-      if (!is_alive->do_object_b(entry->object_peek())) {
+      if (!is_alive->do_object_b(entry->object_raw())) {
         // grab the tag
         jlong tag = entry->tag();
         guarantee(tag != 0, "checking");
@@ -3375,7 +3380,7 @@
         ++freed;
       } else {
         f->do_oop(entry->object_addr());
-        oop new_oop = entry->object_peek();
+        oop new_oop = entry->object_raw();
 
         // if the object has moved then re-hash it and move its
         // entry to its new location.
@@ -3409,7 +3414,7 @@
   // Re-add all the entries which were kept aside
   while (delayed_add != NULL) {
     JvmtiTagHashmapEntry* next = delayed_add->next();
-    unsigned int pos = JvmtiTagHashmap::hash(delayed_add->object_peek(), size);
+    unsigned int pos = JvmtiTagHashmap::hash(delayed_add->object_raw(), size);
     delayed_add->set_next(table[pos]);
     table[pos] = delayed_add;
     delayed_add = next;
